{"version":3,"file":"useHasManyInputController.js","sourceRoot":"","sources":["../../../../src/auto/hooks/useHasManyInputController.tsx"],"names":[],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useMemo } from \"react\";\nimport type { GadgetHasManyConfig } from \"../../internal/gql/graphql.js\";\nimport { useFieldArray, useFormContext } from \"../../useActionForm.js\";\nimport { uniq } from \"../../utils.js\";\nimport type { AutoRelationshipInputProps } from \"../interfaces/AutoRelationshipInputProps.js\";\nimport { useFieldMetadata } from \"./useFieldMetadata.js\";\nimport { useRelatedModelOptions } from \"./useRelatedModelOptions.js\";\n\nexport const useHasManyInputController = (props: AutoRelationshipInputProps) => {\n  const { field } = props;\n  const { getValues } = useFormContext();\n  const fieldMetadata = useFieldMetadata(field);\n  const { metadata, path } = fieldMetadata;\n  const inverseFieldApiIdentifier = useMemo(() => {\n    return (metadata.configuration as GadgetHasManyConfig).inverseField?.apiIdentifier;\n  }, [metadata.configuration]);\n\n  const { fields, remove, append } = useFieldArray({ name: path });\n  const clearAllFields = useCallback(async () => remove(), []);\n\n  const relatedModelOptions = useRelatedModelOptions(props);\n  const { selected, relatedModel } = relatedModelOptions;\n\n  const errorMessage = relatedModel.error?.message ?? selected.error?.message;\n  const isLoading = relatedModel.fetching || selected.fetching;\n\n  const retrievedSelectedRecordIds = selected.records?.map((record: { id: string }) => record.id) ?? [];\n  const unlinkedRecordIds = fields.filter((field: any) => field.__unlinkedInverseField).map((field: any) => field.__id);\n  const formContextValue = getValues(path);\n\n  useEffect(() => {\n    if (!formContextValue) {\n      void clearAllFields(); // This is called asynchronously to avoid an infinite loop\n    }\n  }, [!formContextValue || formContextValue.length === 0]);\n\n  const selectedRecordIds = uniq(\n    [\n      ...fields.map((field, i) => (field as any).__id), // To be selected upon submit\n      ...retrievedSelectedRecordIds, // From related model records in DB\n    ].filter((id) => !unlinkedRecordIds.includes(id))\n  );\n\n  const removeFromFieldsByRecordId = useCallback(\n    (recordId: string) => {\n      const index = fields.findIndex((entry) => (entry as any).__id === recordId);\n      if (index > -1) {\n        remove(index);\n      }\n    },\n    [fields.map((field) => (field as any).__id).join(\",\")]\n  );\n\n  const onRemoveRecord = useCallback(\n    (recordId: string) => {\n      const isSelectedInBackend = retrievedSelectedRecordIds.includes(recordId);\n\n      if (isSelectedInBackend) {\n        append({\n          id: recordId,\n          __id: recordId,\n          __unlinkedInverseField: inverseFieldApiIdentifier!,\n        });\n      } else {\n        // Only selected in frontend\n        removeFromFieldsByRecordId(recordId);\n      }\n    },\n    [inverseFieldApiIdentifier, retrievedSelectedRecordIds]\n  );\n\n  const onSelectRecord = useCallback(\n    (recordId: string) => {\n      const isAlreadySelected = selectedRecordIds.includes(recordId);\n      if (isAlreadySelected) {\n        onRemoveRecord(recordId);\n        return;\n      }\n\n      if (unlinkedRecordIds.includes(recordId)) {\n        // Re-linking a record that is\n        // retrievedFromBackend -> removedInFrontend -> reselectedInFrontend\n        removeFromFieldsByRecordId(recordId);\n      } else {\n        // Adding a new record that was not previously selected\n        append({\n          id: recordId,\n          __id: recordId, // TODO - Investigate utilization of `getValues()` to potentially avoid this __id system\n        });\n      }\n    },\n    [selectedRecordIds, unlinkedRecordIds, inverseFieldApiIdentifier, onRemoveRecord]\n  );\n\n  return {\n    fieldMetadata,\n    relatedModelOptions,\n\n    selectedRecordIds,\n\n    errorMessage,\n    isLoading,\n\n    onSelectRecord,\n    onRemoveRecord,\n  };\n};\n"]}