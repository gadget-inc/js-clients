{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import type {\n  ActionFunction,\n  ActionFunctionMetadata,\n  AnyActionFunction,\n  AnyBackgroundActionHandle,\n  AnyBulkActionFunction,\n  AnyClient,\n  AnyConnection,\n  AnyCoreImplementation,\n  AnyErrorWrapper,\n  BulkActionFunction,\n  DefaultSelection,\n  EnqueueBackgroundActionOptions,\n  FieldSelection,\n  FindFirstFunction,\n  FindManyFunction,\n  FindOneFunction,\n  GadgetRecord,\n  GadgetRecordList,\n  GetFunction,\n  GlobalActionFunction,\n  LimitToKnownKeys,\n  Select,\n  ViewFunction,\n  ViewFunctionWithVariables,\n  ViewFunctionWithoutVariables,\n  ViewResult,\n} from \"@gadgetinc/core\";\nimport type { AnyVariables, DocumentInput, Operation, OperationContext, RequestPolicy } from \"@urql/core\";\nimport type { UseMutationResponse, UseQueryArgs, UseQueryResponse } from \"./adapter.js\";\n\nexport interface QueryOptions {\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n  requestPolicy?: RequestPolicy;\n  suspense?: boolean;\n}\n\n/**\n * All the options controlling how this query will be managed by urql\n * */\nexport declare type ReadOperationOptions = {\n  /** Updates the {@link RequestPolicy} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `requestPolicy` modifies the {@link RequestPolicy} of the GraphQL query operation\n   * that `useQuery` executes, and indicates a caching strategy for cache exchanges.\n   *\n   * For example, when set to `'cache-and-network'`, {@link useQuery} will\n   * receive a cached result with `stale: true` and an API request will be\n   * sent in the background.\n   *\n   * @see {@link OperationContext.requestPolicy} for where this value is set.\n   */\n  requestPolicy?: RequestPolicy;\n  /** Updates the {@link OperationContext} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useQuery}, to update the {@link OperationContext}\n   * of a query operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * Hint: This should be wrapped in a `useMemo` hook, to make sure that your\n   * component doesn’t infinitely update.\n   *\n   * @example\n   * ```ts\n   * const [result, reexecute] = useQuery({\n   *   query,\n   *   context: useMemo(() => ({\n   *     additionalTypenames: ['Item'],\n   *   }), [])\n   * });\n   * ```\n   */\n  context?: Partial<OperationContext>;\n  /** Prevents {@link useQuery} from automatically executing GraphQL query operations.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useQuery} from executing\n   * automatically. The hook will stop receiving updates from the {@link Client}\n   * and won’t execute the query operation, until either it’s set to `false`\n   * or the {@link UseQueryExecute} function is called.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/react-preact/#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  pause?: boolean;\n  /**\n   * Marks this query as one that should suspend the react component rendering while executing, instead of returning `{fetching: true}` to the caller.\n   * Useful if you want to allow components higher in the tree to show spinners instead of having every component manage its own loading state.\n   */\n  suspense?: boolean;\n  /**\n   * Marks this query as a live query that will subscribe to changes from the backend and re-render when backend data changes with the newest data.\n   */\n  live?: boolean;\n};\n\nexport type OptionsType = {\n  [key: string]: any;\n  /** What fields to select from the resulting object */\n  select?: FieldSelection;\n  /** Subscribe to changes from the backend and return a new result as it changes */\n  live?: boolean;\n};\n\n/**\n * The inner result object returned from a query result\n **/\nexport interface ReadHookState<Data = any, Variables extends AnyVariables = Record<string, any>> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: AnyErrorWrapper;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\n/**\n * The return value of a `useGet`, `useFindMany`, `useFindOne` etc hook.\n * Includes the data result object and a refetch function.\n **/\nexport declare type ReadHookResult<Data = any, Variables extends AnyVariables = AnyVariables> = [\n  ReadHookState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport type RequiredKeysOf<BaseType> = Exclude<\n  {\n    [Key in keyof BaseType]: BaseType extends Record<Key, BaseType[Key]> ? Key : never;\n  }[keyof BaseType],\n  undefined\n>;\n\n/**\n * The inner result object returned from a mutation result\n */\nexport interface ActionHookState<Data = any, Variables extends AnyVariables = Record<string, any>> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: AnyErrorWrapper;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\n/**\n * The return value of a `useAction`, `useGlobalAction`, `useBulkAction` etc hook.\n * Includes the data result object and a function for running the mutation.\n **/\nexport type ActionHookResult<Data = any, Variables extends AnyVariables = AnyVariables> = RequiredKeysOf<Variables> extends never\n  ? ActionHookResultWithOptionalCallbackVariables<Data, Variables>\n  : ActionHookResultWithRequiredCallbackVariables<Data, Variables>;\n\nexport type ActionHookResultWithOptionalCallbackVariables<Data = any, Variables extends AnyVariables = AnyVariables> = [\n  ActionHookState<Data, Variables>,\n  (variables?: Variables, context?: Partial<OperationContext>) => Promise<ActionHookState<Data, Variables>>\n];\n\nexport type ActionHookResultWithRequiredCallbackVariables<Data = any, Variables extends AnyVariables = AnyVariables> = [\n  ActionHookState<Data, Variables>,\n  (variables: Variables, context?: Partial<OperationContext>) => Promise<ActionHookState<Data, Variables>>\n];\n\nexport type UseGadgetQueryArgs<Variables extends AnyVariables, Data = any> = UseQueryArgs<Variables, Data> & {\n  /**\n   * Marks this query as one that should suspend the react component rendering while executing, instead of returning `{fetching: true}` to the caller.\n   * Useful if you want to allow components higher in the tree to show spinners instead of having every component manage its own loading state.\n   */\n  suspense?: boolean;\n};\n\n/**\n * Get the current `GadgetConnection` object from context.\n * Must be called within a component wrapped by `<Provider api={...} />`.\n **/\nexport type UseConnection = () => AnyConnection;\n/**\n * Get the current `api` object from  context\n * Must be called within a component wrapped by the `<Provider api={...} />` component.\n **/\nexport type UseApi = () => AnyClient;\n/**\n * Get the current implementation of the core interfaces that a Gadget client uses.\n */\nexport type UseCoreImplementation = () => AnyCoreImplementation;\n/**\n * Memoize and ensure a stable identity on a given value as long as it remains the same, structurally.\n */\nexport type UseStructuralMemo = <T>(value: T) => T;\nexport type UseGadgetQuery = <Data = any, Variables extends AnyVariables = AnyVariables>(\n  args: UseGadgetQueryArgs<Variables, Data>\n) => UseQueryResponse<Data, Variables>;\nexport type UseGadgetMutation = <Data = any, Variables extends AnyVariables = AnyVariables>(\n  query: DocumentInput<Data, Variables>\n) => UseMutationResponse<Data, Variables>;\n\nexport type CoreHooks = {\n  useConnection: UseConnection;\n  useApi: UseApi;\n  useCoreImplementation: UseCoreImplementation;\n  useStructuralMemo: UseStructuralMemo;\n  useGadgetQuery: UseGadgetQuery;\n  useGadgetMutation: UseGadgetMutation;\n};\n\n/**\n * The inner result object returned from a mutation result\n */\nexport type EnqueueHookState<Action extends AnyActionFunction> = Action extends AnyBulkActionFunction\n  ? {\n      fetching: boolean;\n      stale: boolean;\n      handles: AnyBackgroundActionHandle<Action[\"schemaType\"], Action>[] | null;\n      error?: AnyErrorWrapper;\n      extensions?: Record<string, any>;\n      operation?: Operation<{ backgroundAction: { id: string } }, Action[\"variablesType\"]>;\n    }\n  : Action extends ActionFunctionMetadata<any, any, any, any, any, false>\n  ? {\n      fetching: boolean;\n      stale: boolean;\n      handle: AnyBackgroundActionHandle<Action[\"schemaType\"], Action> | null;\n      error?: AnyErrorWrapper;\n      extensions?: Record<string, any>;\n      operation?: Operation<{ backgroundAction: { id: string } }, Action[\"variablesType\"]>;\n    }\n  : {\n      fetching: boolean;\n      stale: boolean;\n      handle: AnyBackgroundActionHandle<unknown, Action> | null;\n      error?: AnyErrorWrapper;\n      extensions?: Record<string, any>;\n      operation?: Operation<{ backgroundAction: { id: string } }, Action[\"variablesType\"]>;\n    };\n\n/**\n * The return value of a `useEnqueue` hook.\n * Returns a two-element array:\n *  - the result object, with the keys like `handle`, `fetching`, and `error`\n *  - and a function for running the enqueue mutation.\n **/\nexport type EnqueueHookResult<Action extends AnyActionFunction> = RequiredKeysOf<\n  Exclude<Action[\"variablesType\"], null | undefined>\n> extends never\n  ? [\n      EnqueueHookState<Action>,\n      (\n        variables?: Action[\"variablesType\"],\n        backgroundOptions?: EnqueueBackgroundActionOptions<Action>,\n        context?: Partial<OperationContext>\n      ) => Promise<EnqueueHookState<Action>>\n    ]\n  : [\n      EnqueueHookState<Action>,\n      (\n        variables: Action[\"variablesType\"],\n        backgroundOptions?: EnqueueBackgroundActionOptions<Action>,\n        context?: Partial<OperationContext>\n      ) => Promise<EnqueueHookState<Action>>\n    ];\n\n/**\n * Hook to run a Gadget model action. `useAction` must be passed an action function from an instance of your generated API client library, like `api.user.create` or `api.blogPost.publish`. `useAction` doesn't actually run the action when invoked, but instead returns an action function as the second result for running the action in response to an event.\n *\n * @param action an action function from a model manager in your application's client, like `api.user.create`\n * @param options action options, like selecting the fields in the result\n *\n * @example\n * export function CreateUserButton(props: { name: string; email: string }) {\n *   const [{error, fetching, data}, createUser] = useAction(api.user.create, {\n *     select: {\n *       id: true,\n *     },\n *   });\n *\n *   const onClick = () => createUser({\n *     name: props.name,\n *     email: props.email,\n *   });\n *\n *   return (\n *     <>\n *       {error && <>Failed to create user: {error.toString()}</>}\n *       {fetching && <>Creating user...</>}\n *       {data && <>Created user with id={data.id}</>}\n *       <button onClick={onClick}>Create user</button>\n *     </>\n *   );\n * }\n */\n\nexport type UseAction = <\n  GivenOptions extends OptionsType,\n  SchemaT,\n  F extends ActionFunction<GivenOptions, any, any, SchemaT, any>,\n  Options extends F[\"optionsType\"]\n>(\n  action: F,\n  options?: LimitToKnownKeys<Options, F[\"optionsType\"]>\n) => ActionHookResult<\n  F[\"hasReturnType\"] extends true\n    ? any\n    : GadgetRecord<\n        Select<Exclude<F[\"schemaType\"], null | undefined>, DefaultSelection<F[\"selectionType\"], Options, F[\"defaultSelection\"]>>\n      >,\n  Exclude<F[\"variablesType\"], null | undefined>\n>;\n\n/**\n * Hook to run a Gadget model bulk action.\n *\n * @param action any bulk action function from a Gadget manager\n * @param options action options, like selecting the fields in the result\n *\n * @example\n * ```\n * export function BulkFinish(props: { ids: string[]; }) {\n *   const [result, bulkFinish] = useBulkAction(Client.todo.bulkFinish, {\n *     select: {\n *       id: true,\n *     },\n *   });\n *\n *   const onClick = () => ;\n *\n *   return (\n *     <>\n *       {result.error && <>Failed to create user: {result.error.toString()}</>}\n *       {result.fetching && <>Creating user...</>}\n *       {result.data && <>Finished TODOs with ids={props.ids}</>}\n *       <button onClick={() => bulkFinish(ids))}>Bulk finish</button>\n *     </>\n *   );\n * }\n */\nexport type UseBulkAction = <\n  GivenOptions extends OptionsType,\n  SchemaT,\n  F extends BulkActionFunction<GivenOptions, any, any, SchemaT, any>,\n  Options extends F[\"optionsType\"]\n>(\n  action: F,\n  options?: LimitToKnownKeys<Options, F[\"optionsType\"]>\n) => ActionHookResult<\n  F[\"hasReturnType\"] extends true\n    ? any[]\n    : GadgetRecord<\n        Select<Exclude<F[\"schemaType\"], null | undefined>, DefaultSelection<F[\"selectionType\"], Options, F[\"defaultSelection\"]>>\n      >[],\n  Exclude<F[\"variablesType\"], null | undefined>\n>;\n\n/**\n * Hook to enqueue a Gadget action in the background. `useEnqueue` must be passed an action function from an instance of your generated API client library, like `useEnqueue(api.user.create)` or `useEnqueue(api.someGlobalAction)`. `useEnqueue` doesn't actually submit the background action when invoked, but instead returns a function for enqueuing the action in response to an event.\n *\n * @param action a model action or global action in your application's client, like `api.user.create` or `api.someGlobalAction`\n * @param options action options, like selecting the fields in the result\n *\n * @example\n * export function CreateUserButton(props: { name: string; email: string }) {\n *   const [{error, fetching, handle}, enqueue] = useEnqueue(api.user.create));\n *\n *   const onClick = () => enqueue(\n *     {\n *       name: props.name,\n *       email: props.email,\n *     }, {\n *       id: `send-email-action-${props.email}`\n *     }\n *   );\n *\n *   return (\n *     <>\n *       {error && <>Failed to enqueue user create: {error.toString()}</>}\n *       {fetching && <>Enqueuing action...</>}\n *       {data && <>Enqueued action with background action id={handle.id}</>}\n *       <button onClick={onClick}>Create user</button>\n *     </>\n *   );\n * }\n */\nexport type UseEnqueue = <Action extends AnyActionFunction>(\n  action: Action,\n  baseBackgroundOptions?: EnqueueBackgroundActionOptions<Action>\n) => EnqueueHookResult<Action>;\n\nexport interface FetchHookOptions extends RequestInit {\n  stream?: boolean | string;\n  json?: boolean;\n  sendImmediately?: boolean;\n  onStreamComplete?: (value: string) => void;\n}\n\nexport interface FetchHookState<T> {\n  data?: T;\n  response?: Response;\n  error?: AnyErrorWrapper;\n  fetching: boolean;\n  streaming: boolean;\n  options: FetchHookOptions;\n}\n\nexport type FetchHookResult<T, U = T> = [FetchHookState<T>, (opts?: Partial<FetchHookOptions>) => Promise<U>];\n\n/**\n * Hook to make an HTTP request to a Gadget backend HTTP route. Preserves client side session information and ensures it's passed along to the backend.\n *\n * Returns a tuple with the current state of the request and a function to send or re-send the request. The state is an object with the following fields:\n * - `data`: the response data, if the request was successful\n * - `fetching`: a boolean describing if the fetch request is currently in progress\n * - `streaming`: a boolean describing if the fetch request is currently streaming. This is only set when the option `{ stream: \"string\" }` is passed\n * - `error`: an error object if the request failed in any way\n *\n * The second return value is a function for executing the fetch request. It returns a promise for the response body.\n *\n * By default, `GET` requests are sent as soon as the hook executes. Any other request methods are not sent automatically, and must be triggered by calling the `execute` function returned in the second argument.\n *\n * Pass the `{ json: true }` option to expect a JSON response from the server, and to automatically parse the response as JSON. Otherwise, the response will be returned as a `string` object.\n *\n * Pass the `{ stream: true }` to get a `ReadableStream` object as a response from the server, allowing you to work with the response as it arrives.\n *\n * Pass the `{ stream: \"string\" }` to decode the `ReadableStream` as a string and update data as it arrives. If the stream is in an encoding other than utf8 use i.e. `{ stream: \"utf-16\" }`.\n *\n * When `{ stream: \"string\" }` is used, the `streaming` field in the state will be set to `true` while the stream is active, and `false` when the stream is complete. You can use this to show a loading indicator while the stream is active.\n * You can also pass an `onStreamComplete` callback that will be called with the value of the streamed string once it has completed.\n *\n * If you want to read model data, see the `useFindMany` function and similar. If you want to invoke a backend Action, use the `useAction` hook instead.\n *\n * @param path the backend path to fetch\n * @param options the `fetch` options for the request\n *\n * @example\n * ```\n * export function UserByEmail(props: { email: string }) {\n *   const [{data, fetching, error}, refresh] = useFetch(\"/users/get\", {\n *     method: \"GET\",\n *     body: JSON.stringify({ email: props.email }})\n *     headers: {\n *       \"content-type\": \"application/json\",\n *     }\n *     json: true,\n *   });\n *\n *   if (result.error) return <>Error: {result.error.toString()}</>;\n *   if (result.fetching && !result.data) return <>Fetching...</>;\n *   if (!result.data) return <>No user found with id={props.id}</>;\n *\n *   return <div>{result.data.name}</div>;\n * }\n */\nexport interface UseFetch {\n  (path: string, options: { stream: string } & FetchHookOptions): FetchHookResult<string, ReadableStream<string>>;\n  (path: string, options: { stream: true } & FetchHookOptions): FetchHookResult<ReadableStream<Uint8Array>>;\n  <T extends Record<string, any>>(url: string, options: { json: true } & FetchHookOptions): FetchHookResult<T>;\n  (path: string, options?: FetchHookOptions): FetchHookResult<string>;\n}\n\n/**\n * Hook to fetch a Gadget record using the `findByXYZ` method of a given model manager. Useful for finding records by key fields which are used for looking up records by. Gadget autogenerates the `findByXYZ` methods on your model managers, and `useFindBy` can only be used with models that have these generated finder functions.\n *\n * @param finder `findByXYZ` function from a Gadget manager that will be used\n * @param value field value of the record to fetch\n * @param options options for selecting the fields in the result\n *\n * @example\n * ```\n * export function UserByEmail(props: { email: string }) {\n *   const [result, refresh] = useFindBy(api.user.findByEmail, props.email, {\n *     select: {\n *       name: true,\n *     },\n *   });\n *\n *   if (result.error) return <>Error: {result.error.toString()}</>;\n *   if (result.fetching && !result.data) return <>Fetching...</>;\n *   if (!result.data) return <>No user found with id={props.id}</>;\n *\n *   return <div>{result.data.name}</div>;\n * }\n */\nexport type UseFindBy = <\n  GivenOptions extends OptionsType,\n  SchemaT,\n  F extends FindOneFunction<GivenOptions, any, SchemaT, any>,\n  Options extends F[\"optionsType\"] & ReadOperationOptions\n>(\n  finder: F,\n  value: string,\n  options?: LimitToKnownKeys<Options, F[\"optionsType\"] & ReadOperationOptions>\n) => ReadHookResult<\n  GadgetRecord<Select<Exclude<F[\"schemaType\"], null | undefined>, DefaultSelection<F[\"selectionType\"], Options, F[\"defaultSelection\"]>>>\n>;\n\n/**\n * Hook to fetch the first backend record matching a given filter and sort. Returns a standard hook result set with a tuple of the result object with `data`, `fetching`, and `error` keys, and a `refetch` function. `data` will be the first record found if there is one, and null otherwise.\n *\n * @param manager Gadget model manager to use\n * @param options options for filtering and searching records, and selecting the fields in each record of the result\n *\n * @example\n *\n * ```\n * export function Users() {\n *   const [result, refresh] = useFindFirst(api.user, {\n *     select: {\n *       name: true,\n *     },\n *   });\n *\n *   if (result.error) return <>Error: {result.error.toString()}</>;\n *   if (result.fetching && !result.data) return <>Fetching...</>;\n *   if (!result.data) return <>No user found</>;\n *\n *   return <div>{result.data.name}</div>;\n * }\n * ```\n */\nexport type UseFindFirst = <\n  GivenOptions extends OptionsType,\n  SchemaT,\n  F extends FindFirstFunction<GivenOptions, any, SchemaT, any>,\n  Options extends F[\"optionsType\"] & ReadOperationOptions\n>(\n  manager: { findFirst: F },\n  options?: LimitToKnownKeys<Options, F[\"optionsType\"] & ReadOperationOptions>\n) => ReadHookResult<\n  GadgetRecord<Select<Exclude<F[\"schemaType\"], null | undefined>, DefaultSelection<F[\"selectionType\"], Options, F[\"defaultSelection\"]>>>\n>;\n\n/**\n * Hook to fetch a page of Gadget records from the backend, optionally sorted, filtered, searched, and selected from. Returns a standard hook result set with a tuple of the result object with `data`, `fetching`, and `error` keys, and a `refetch` function. `data` will be a `GadgetRecordList` object holding the list of returned records and pagination info.\n *\n * @param manager Gadget model manager to use\n * @param options options for filtering and searching records, and selecting the fields in each record of the result\n *\n * @example\n *\n * ```\n * export function Users() {\n *   const [result, refresh] = useFindMany(api.user, {\n *     select: {\n *       name: true,\n *     },\n *   });\n *\n *   if (result.error) return <>Error: {result.error.toString()}</>;\n *   if (result.fetching && !result.data) return <>Fetching...</>;\n *   if (!result.data) return <>No users found</>;\n *\n *   return <>{result.data.map((user) => <div>{user.name}</div>)}</>;\n * }\n * ```\n */\nexport type UseFindMany = <\n  GivenOptions extends OptionsType,\n  SchemaT,\n  F extends FindManyFunction<GivenOptions, any, SchemaT, any>,\n  Options extends F[\"optionsType\"] & ReadOperationOptions\n>(\n  manager: { findMany: F },\n  options?: LimitToKnownKeys<Options, F[\"optionsType\"] & ReadOperationOptions>\n) => ReadHookResult<\n  GadgetRecordList<Select<Exclude<F[\"schemaType\"], null | undefined>, DefaultSelection<F[\"selectionType\"], Options, F[\"defaultSelection\"]>>>\n>;\n\n/**\n * Hook to fetch one Gadget record by `id` from the backend. Returns a standard hook result set with a tuple of the result object with `data`, `fetching`, and `error` keys, and a `refetch` function. `data` will be the record if it was found, and `null` otherwise.\n *\n * @param manager Gadget model manager to use\n * @param id id of the record to fetch\n * @param options options for selecting the fields in the result\n *\n * @example\n * ```\n * export function User(props: { id: string }) {\n *   const [result, refresh] = useFindOne(api.user, props.id, {\n *     select: {\n *       name: true,\n *     },\n *   });\n *\n *   if (result.error) return <>Error: {result.error.toString()}</>;\n *   if (result.fetching && !result.data) return <>Fetching...</>;\n *   if (!result.data) return <>No user found with id={props.id}</>;\n *\n *   return <div>{result.data.name}</div>;\n * }\n * ```\n */\nexport type UseFindOne = <\n  GivenOptions extends OptionsType,\n  SchemaT,\n  F extends FindOneFunction<GivenOptions, any, SchemaT, any>,\n  Options extends F[\"optionsType\"] & ReadOperationOptions\n>(\n  manager: { findOne: F },\n  id: string,\n  options?: LimitToKnownKeys<Options, F[\"optionsType\"] & ReadOperationOptions>\n) => ReadHookResult<\n  GadgetRecord<Select<Exclude<F[\"schemaType\"], null | undefined>, DefaultSelection<F[\"selectionType\"], Options, F[\"defaultSelection\"]>>>\n>;\n\n/**\n * Hook that fetches a singleton record for an `api.currentSomething` style model manager. `useGet` fetches one global record, which is most often the current session. `useGet` doesn't require knowing the record's ID in order to fetch it, and instead returns the one current record for the current context.\n *\n * @param manager Gadget model manager to use, like `api.currentSomething`\n * @param options options for selecting the fields in the result\n *\n * @example\n * ```\n * export function CurrentSession() {\n *   const [{error, data, fetching}, refresh] = useGet(api.currentSession, {\n *     select: {\n *       id: true,\n *       userId: true,\n *     },\n *   });\n *\n *   if (error) return <>Error: {error.toString()}</>;\n *   if (fetching && !data) return <>Fetching...</>;\n *   if (!data) return <>No current session found</>;\n *\n *   return <div>Current session ID={data.id} and userId={data.userId}</div>;\n * }\n * ```\n */\nexport type UseGet = <\n  GivenOptions extends OptionsType,\n  SchemaT,\n  F extends GetFunction<GivenOptions, any, SchemaT, any>,\n  Options extends F[\"optionsType\"] & ReadOperationOptions\n>(\n  manager: { get: F },\n  options?: LimitToKnownKeys<Options, F[\"optionsType\"] & ReadOperationOptions>\n) => ReadHookResult<\n  GadgetRecord<Select<Exclude<F[\"schemaType\"], null | undefined>, DefaultSelection<F[\"selectionType\"], Options, F[\"defaultSelection\"]>>>\n>;\n\n/**\n * Hook to run a Gadget model action.\n *\n * @param action any action function from a Gadget manager\n *\n * @example\n * ```\n * export function FlipAllWidgets(props: { name: string; email: string }) {\n *   const [result, flipAllWidgets] = useGlobalAction(Client.flipAllWidgets);\n *\n *   return (\n *     <>\n *       {result.error && <>Failed to flip all widgets: {result.error.toString()}</>}\n *       {result.fetching && <>Flipping all widgets...</>}\n *       {result.data && <>Flipped all widgets</>}\n *       <button onClick={() => flipAllWidgets()}>Flip all widgets</button>\n *     </>\n *   );\n * }\n */\nexport type UseGlobalAction = <F extends GlobalActionFunction<any>>(\n  action: F\n) => ActionHookResultWithOptionalCallbackVariables<any, Exclude<F[\"variablesType\"], null | undefined>>;\n\n/**\n *  Hook to fetch many Gadget records using the `maybeFindFirst` method of a given manager.\n *\n * @param manager Gadget model manager to use\n * @param options options for filtering and searching records, and selecting the fields in each record of the result\n *\n * @example\n *\n * ```\n * export function Users() {\n *   const [result, refresh] = useMaybeFindFirst(Client.user, {\n *     select: {\n *       name: true,\n *     },\n *   });\n *\n *   if (result.error) return <>Error: {result.error.toString()}</>;\n *   if (result.fetching && !result.data) return <>Fetching...</>;\n *   if (!result.data) return <>No user found</>;\n *\n *   return <div>{result.data.name}</div>;\n * }\n * ```\n */\nexport type UseMaybeFindFirst = <\n  GivenOptions extends OptionsType,\n  SchemaT,\n  F extends FindFirstFunction<GivenOptions, any, SchemaT, any>,\n  Options extends F[\"optionsType\"] & ReadOperationOptions\n>(\n  manager: { findFirst: F },\n  options?: LimitToKnownKeys<Options, F[\"optionsType\"] & ReadOperationOptions>\n) => ReadHookResult<null | GadgetRecord<\n  Select<Exclude<F[\"schemaType\"], null | undefined>, DefaultSelection<F[\"selectionType\"], Options, F[\"defaultSelection\"]>>\n>>;\n\n/**\n * Hook to fetch a Gadget record using the `maybeFindOne` method of a given manager.\n *\n * @param manager Gadget model manager to use\n * @param id id of the record to fetch\n * @param options options for selecting the fields in the result\n *\n * @example\n * ```\n * export function User(props: { id: string }) {\n *   const [result, refresh] = useMaybeFindOne(Client.user, props.id, {\n *     select: {\n *       name: true,\n *     },\n *   });\n *\n *   if (result.error) return <>Error: {result.error.toString()}</>;\n *   if (result.fetching && !result.data) return <>Fetching...</>;\n *   if (!result.data) return <>No user found with id={props.id}</>;\n *\n *   return <div>{result.data.name}</div>;\n * }\n * ```\n */\nexport type UseMaybeFindOne = <\n  GivenOptions extends OptionsType, // currently necessary for Options to be a narrow type (e.g., `true` instead of `boolean`)\n  SchemaT,\n  F extends FindOneFunction<GivenOptions, any, SchemaT, any>,\n  Options extends F[\"optionsType\"] & ReadOperationOptions\n>(\n  manager: { findOne: F },\n  id: string,\n  options?: LimitToKnownKeys<Options, F[\"optionsType\"] & ReadOperationOptions>\n) => ReadHookResult<null | GadgetRecord<\n  Select<Exclude<F[\"schemaType\"], null | undefined>, DefaultSelection<F[\"selectionType\"], Options, F[\"defaultSelection\"]>>\n>>;\n\nexport interface UseView {\n  /**\n   * Hook to fetch the result of a computed view from the backend. Returns a standard hook result set with a tuple of the result object with `data`, `fetching`, and `error` keys, and a `refetch` function. `data` will be the shape of the computed view's result.\n   *\n   * @param view Gadget view function to run, like `api.leaderboard` or `api.todos.summary`\n   * @param options options for controlling client side execution\n   *\n   * @example\n   *\n   * ```\n   * export function Leaderboard() {\n   *   const [result, refresh] = useView(api.leaderboard);\n   *\n   *   if (result.error) return <>Error: {result.error.toString()}</>;\n   *   if (result.fetching && !result.data) return <>Fetching...</>;\n   *   if (!result.data) return <>No data found</>;\n   *\n   *   return <>{result.data.map((leaderboard) => <div>{leaderboard.name}: {leaderboard.score}</div>)}</>;\n   * }\n   * ```\n   */\n  <F extends ViewFunctionWithoutVariables<any>>(view: F, options?: Omit<ReadOperationOptions, \"live\">): ReadHookResult<ViewResult<F>>;\n  /**\n   * Hook to fetch the result of a computed view with variables from the backend. Returns a standard hook result set with a tuple of the result object with `data`, `fetching`, and `error` keys, and a `refetch` function. `data` will be the shape of the computed view's result.\n   *\n   * @param manager Gadget view function to run\n   * @param variables variables to pass to the backend view\n   * @param options options for controlling client side execution\n   *\n   * @example\n   *\n   * ```\n   * export function Leaderboard() {\n   *   const [result, refresh] = useView(api.leaderboard, {\n   *     first: 10,\n   *   });\n   *\n   *   if (result.error) return <>Error: {result.error.toString()}</>;\n   *   if (result.fetching && !result.data) return <>Fetching...</>;\n   *   if (!result.data) return <>No data found</>;\n   *\n   *   return <>{result.data.map((leaderboard) => <div>{leaderboard.name}: {leaderboard.score}</div>)}</>;\n   * }\n   * ```\n   */\n  <F extends ViewFunctionWithVariables<any, any>>(\n    view: F,\n    variables: F[\"variablesType\"],\n    options?: Omit<ReadOperationOptions, \"live\">\n  ): ReadHookResult<ViewResult<F>>;\n\n  /**\n   * Hook to fetch the result of an inline computed view with variables from the backend. Returns a standard hook result set with a tuple of the result object with `data`, `fetching`, and `error` keys, and a `refetch` function. `data` will be the shape of the computed view's result.\n   *\n   * Does not know the type of the result from the input string -- for type safety, use a named view defined in a .gelly file in the backend.\n   *\n   * @param view Gelly query string to run, like `{ count(todos) }`\n   * @param variables variables to pass to the backend view\n   * @param options options for controlling client side execution\n   *\n   * @example\n   *\n   * ```\n   * export function Leaderboard() {\n   *   const [result, refresh] = useView(\"{ count(todos) }\", {\n   *     first: 10,\n   *   });\n   *\n   *   if (result.error) return <>Error: {result.error.toString()}</>;\n   *   if (result.fetching && !result.data) return <>Fetching...</>;\n   *   if (!result.data) return <>No data found</>;\n   *\n   *   return <>{result.data.map((leaderboard) => <div>{leaderboard.name}: {leaderboard.score}</div>)}</>;\n   * }\n   * ```\n   */\n  (gellyQuery: string, variables?: Record<string, unknown>, options?: Omit<ReadOperationOptions, \"live\">): ReadHookResult<\n    ViewResult<ViewFunction<unknown, unknown>>\n  >;\n}\n"]}