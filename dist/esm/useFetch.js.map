{"version":3,"file":"useFetch.js","sourceRoot":"","sources":["../../src/useFetch.ts"],"names":[],"mappings":"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","sourcesContent":["import type { AnyErrorWrapper } from \"@gadgetinc/core\";\nimport type { RuntimeAdapter } from \"./adapter.js\";\nimport { createHookStub } from \"./createHooks.js\";\nimport type { CoreHooks, FetchHookOptions, FetchHookResult, FetchHookState, UseFetch } from \"./types.js\";\n\ntype FetchAction<T> =\n  | { type: \"fetching\" }\n  | { type: \"streaming\" }\n  | { type: \"fetched\"; payload: T }\n  | { type: \"streamed\" }\n  | { type: \"update\"; payload: T }\n  | { type: \"error\"; payload: AnyErrorWrapper };\n\nconst reducer = <T>(state: FetchHookState<T>, action: FetchAction<T>): FetchHookState<T> => {\n  switch (action.type) {\n    case \"fetching\":\n      return { ...state, fetching: true, streaming: false, error: undefined };\n    case \"streaming\":\n      return { ...state, streaming: true };\n    case \"streamed\":\n      return { ...state, streaming: false };\n    case \"fetched\":\n      return { ...state, fetching: false, data: action.payload, error: undefined };\n    case \"update\":\n      return { ...state, data: action.payload };\n    case \"error\":\n      return { ...state, fetching: false, error: action.payload };\n    default:\n      return state;\n  }\n};\n\nconst startRequestByDefault = (options?: FetchHookOptions) => {\n  if (typeof options?.sendImmediately != \"undefined\") {\n    return options.sendImmediately;\n  } else {\n    return !options?.method || options.method === \"GET\";\n  }\n};\n\nconst dispatchError = (\n  wrapClientSideError: (error: any, response?: Response) => AnyErrorWrapper,\n  mounted: { current: boolean },\n  dispatch: (action: FetchAction<any>) => void,\n  abortController: AbortController,\n  error: any,\n  response?: Response\n) => {\n  if (!mounted.current || abortController.signal.aborted) return null;\n\n  const wrapped = wrapClientSideError(error, response);\n  dispatch({ type: \"error\", payload: wrapped });\n\n  return wrapped;\n};\n\nexport let useFetch: UseFetch = createHookStub(\"useFetch\", (adapter: RuntimeAdapter, coreHooks: CoreHooks) => {\n  useFetch = <T = string>(path: string, options?: FetchHookOptions): FetchHookResult<T> => {\n    // Used to prevent state update if the component is unmounted\n    const mounted = adapter.framework.useRef<boolean>(true);\n    const { onStreamComplete, ...optionsToMemoize } = options ?? {};\n    const memoizedOptions = coreHooks.useStructuralMemo<FetchHookOptions>(optionsToMemoize);\n    const connection = coreHooks.useConnection();\n    const { wrapClientSideError } = coreHooks.useCoreImplementation();\n    const startRequestOnMount = startRequestByDefault(memoizedOptions);\n    const controller = adapter.framework.useRef<AbortController | null>(null);\n\n    const [state, dispatch] = adapter.framework.useReducer<FetchHookState<T>, FetchHookOptions, [FetchAction<T>]>(\n      reducer,\n      memoizedOptions,\n      (memoizedOptions) => {\n        return { fetching: startRequestOnMount, streaming: false, options: memoizedOptions };\n      }\n    );\n\n    const send = adapter.framework.useCallback(\n      async (sendOptions?: Partial<FetchHookOptions>): Promise<T> => {\n        if (controller.current && !controller.current.signal.aborted) {\n          controller.current.abort(\"useFetch is starting a new request, aborting the previous one\");\n        }\n\n        const abortContoller = new AbortController();\n        controller.current = abortContoller;\n\n        dispatch({ type: \"fetching\" });\n\n        let data: any;\n        let response: Response | undefined = undefined;\n\n        const mergedOptions = { ...memoizedOptions, onStreamComplete, ...sendOptions };\n\n        // add implicit headers from options, being careful not to mutate any inputs\n        if (mergedOptions.json) {\n          mergedOptions.headers = { ...mergedOptions.headers };\n          (mergedOptions.headers as any)[\"accept\"] ??= \"application/json\";\n        }\n\n        try {\n          const { json: _json, stream: _stream, onStreamComplete: _onStreamComplete, ...fetchOptions } = mergedOptions;\n          // make the fetch call using GadgetConnection to pass along auth and other headers\n          response = await connection.fetch(path, { signal: abortContoller.signal, ...fetchOptions });\n          if (!response.ok) {\n            throw new Error(response.statusText);\n          }\n\n          let dispatchData = true;\n\n          if (mergedOptions.json) {\n            data = await response.json();\n          } else if (typeof mergedOptions.stream === \"string\") {\n            dispatchData = false;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const decodedStream = response.body!.pipeThrough(\n              new TextDecoderStream(mergedOptions.stream === \"string\" ? \"utf8\" : mergedOptions.stream)\n            );\n\n            const [responseStream, updateStream] = decodedStream.tee();\n\n            data = responseStream;\n            const decodedStreamReader = updateStream.getReader();\n\n            decodedStreamReader.closed.catch((error: any) => {\n              dispatchError(wrapClientSideError, mounted, dispatch, abortContoller, error, response);\n            });\n\n            dispatch({ type: \"fetched\", payload: \"\" as any });\n\n            (async () => {\n              let responseText = \"\";\n              let done = false;\n\n              dispatch({ type: \"streaming\" });\n\n              while (!done) {\n                const { value, done: _done } = await decodedStreamReader.read();\n                done = _done;\n\n                if (value) {\n                  responseText += value;\n\n                  if (!abortContoller.signal.aborted) {\n                    dispatch({ type: \"update\", payload: responseText as any });\n                  }\n                }\n              }\n\n              mergedOptions.onStreamComplete?.(responseText);\n            })()\n              .catch((error: any) => {\n                dispatchError(wrapClientSideError, mounted, dispatch, abortContoller, error, response);\n              })\n              .finally(() => {\n                dispatch({ type: \"streamed\" });\n              });\n          } else if (mergedOptions.stream) {\n            data = response.body;\n          } else {\n            data = await response.text();\n          }\n\n          if (!mounted.current || !dispatchData) return data;\n\n          dispatch({ type: \"fetched\", payload: data });\n        } catch (error: any) {\n          const wrapped = dispatchError(wrapClientSideError, mounted, dispatch, abortContoller, error, response);\n          if (!wrapped) return null as any;\n          throw wrapped;\n        }\n        return data;\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [connection, memoizedOptions, path]\n    );\n\n    // track if we're mounted or not\n    adapter.framework.useEffect(() => {\n      mounted.current = true;\n\n      return () => {\n        mounted.current = false;\n      };\n    }, []);\n\n    // execute the initial request on mount if needed\n    adapter.framework.useEffect(() => {\n      if (startRequestOnMount) {\n        void send().catch(() => {\n          // error will be reported via the return value of the hook\n        });\n      }\n\n      // abort if the component is unmounted, or if one of the key elements of the request changes such that we don't want an outstanding request's result anymore\n      return () => {\n        controller.current?.abort();\n      };\n    }, [path, startRequestOnMount, send]);\n\n    return [state, send];\n  };\n});\n"]}