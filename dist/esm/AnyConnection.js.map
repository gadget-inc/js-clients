{"version":3,"file":"AnyConnection.js","sourceRoot":"","sources":["../../src/AnyConnection.ts"],"names":[],"mappings":"AAWA;;;;;IAKI;AACJ,MAAM,CAAN,IAAY,kBAOX;AAPD,WAAY,kBAAkB;IAC5B,wDAAkC,CAAA;IAClC,wCAAkB,CAAA;IAClB,2CAAqB,CAAA;IACrB,+DAAyC,CAAA;IACzC,6CAAuB,CAAA;IACvB,uCAAiB,CAAA;AACnB,CAAC,EAPW,kBAAkB,KAAlB,kBAAkB,QAO7B","sourcesContent":["import type { Client, ClientOptions } from \"@urql/core\";\nimport type { ClientOptions as SubscriptionClientOptions, createClient as createSubscriptionClient } from \"graphql-ws\";\nimport type { AuthenticationModeOptions, Exchanges } from \"./ClientOptions.js\";\nimport { GadgetTransaction } from \"./GadgetTransaction.js\";\n\nexport interface GadgetSubscriptionClientOptions extends Partial<SubscriptionClientOptions> {\n  urlParams?: Record<string, string | null | undefined>;\n  connectionAttempts?: number;\n  connectionGlobalTimeoutMs?: number;\n}\n\n/**\n * Represents the current strategy for authenticating with the Gadget platform.\n * For individual users in web browsers, we authenticate using a session token stored client side, like a cookie, but with cross domain support.\n * For server to server communication, or traceable access from the browser, we use pre shared secrets called API Keys\n * And when within the Gadget platform itself, we use a private secret token called an Internal Auth Token. Internal Auth Tokens are managed by Gadget and should never be used by external developers.\n **/\nexport enum AuthenticationMode {\n  BrowserSession = \"browser-session\",\n  APIKey = \"api-key\",\n  Internal = \"internal\",\n  InternalAuthToken = \"internal-auth-token\",\n  Anonymous = \"anonymous\",\n  Custom = \"custom\",\n}\n\nexport interface GadgetConnectionOptions {\n  endpoint: string;\n  authenticationMode?: AuthenticationModeOptions;\n  websocketsEndpoint?: string;\n  subscriptionClientOptions?: GadgetSubscriptionClientOptions;\n  websocketImplementation?: typeof globalThis.WebSocket;\n  fetchImplementation?: typeof globalThis.fetch;\n  environment?: string;\n  requestPolicy?: ClientOptions[\"requestPolicy\"];\n  applicationId?: string;\n  baseRouteURL?: string;\n  exchanges?: Exchanges;\n  createSubscriptionClient?: typeof createSubscriptionClient;\n}\n\nexport type TransactionRun<T> = (transaction: GadgetTransaction) => Promise<T>;\n\nexport interface AnyConnection {\n  endpoint: string;\n  authenticationMode: AuthenticationMode;\n  createSubscriptionClient: typeof createSubscriptionClient;\n  options: GadgetConnectionOptions;\n  get currentClient(): Client;\n  transaction: {\n    <T>(options: GadgetSubscriptionClientOptions, run: TransactionRun<T>): Promise<T>;\n    <T>(run: TransactionRun<T>): Promise<T>;\n  };\n  close(): void;\n  fetch: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;\n}\n"]}