{"version":3,"file":"useWidgetState.js","sourceRoot":"","sources":["../../../src/hooks/useWidgetState.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,SAAS,EAAE,QAAQ,EAAuB,MAAM,OAAO,CAAC;AAE9E,OAAO,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAC;AA2BvD,MAAM,UAAU,cAAc,CAC5B,YAA0C;IAE1C,MAAM,qBAAqB,GAAG,eAAe,CAAC,aAAa,CAAM,CAAC;IAElE,MAAM,CAAC,WAAW,EAAE,eAAe,CAAC,GAAG,QAAQ,CAAW,GAAG,EAAE;QAC7D,IAAI,qBAAqB,IAAI,IAAI,EAAE,CAAC;YAClC,OAAO,qBAAqB,CAAC;QAC/B,CAAC;QAED,OAAO,OAAO,YAAY,KAAK,UAAU,CAAC,CAAC,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC,YAAY,IAAI,IAAI,CAAC;IACpF,CAAC,CAAC,CAAC;IAEH,SAAS,CAAC,GAAG,EAAE;QACb,eAAe,CAAC,qBAAqB,CAAC,CAAC;IACzC,CAAC,EAAE,CAAC,qBAAqB,CAAC,CAAC,CAAC;IAE5B,MAAM,cAAc,GAAG,WAAW,CAChC,CAAC,KAA+B,EAAE,EAAE;QAClC,eAAe,CAAC,CAAC,SAAS,EAAE,EAAE;YAC5B,MAAM,QAAQ,GAAG,OAAO,KAAK,KAAK,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;YAExE,IAAI,QAAQ,IAAI,IAAI,EAAE,CAAC;gBACrB,KAAK,MAAM,CAAC,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;YAC9C,CAAC;YAED,OAAO,QAAQ,CAAC;QAClB,CAAC,CAAC,CAAC;IACL,CAAC,EACD,CAAC,MAAM,CAAC,MAAM,CAAC,cAAc,CAAC,CAC/B,CAAC;IAEF,OAAO,CAAC,WAAW,EAAE,cAAc,CAAU,CAAC;AAChD,CAAC","sourcesContent":["import { useCallback, useEffect, useState, type SetStateAction } from \"react\";\nimport { type UnknownObject } from \"../types.js\";\nimport { useOpenAiGlobal } from \"./useOpenAiGlobal.js\";\n\n/**\n * Hook for managing persistent widget state in a ChatGPT app.\n *\n * Similar to React's `useState`, but the state is synchronized with ChatGPT's\n * widget state system. This allows state to persist across re-renders and\n * display mode changes. When the state is updated, it's automatically saved\n * to ChatGPT's storage system.\n *\n * @param defaultState - Default state value or function returning default state\n * @returns A tuple of [state, setState] similar to React's useState\n *\n * @example\n * ```tsx\n * const [count, setCount] = useWidgetState({ count: 0 });\n * return (\n *   <button onClick={() => setCount({ count: count.count + 1 })}>\n *     Count: {count?.count ?? 0}\n *   </button>\n * );\n * ```\n */\nexport function useWidgetState<T extends UnknownObject>(defaultState: T | (() => T)): readonly [T, (state: SetStateAction<T>) => void];\nexport function useWidgetState<T extends UnknownObject>(\n  defaultState?: T | (() => T | null) | null\n): readonly [T | null, (state: SetStateAction<T | null>) => void];\nexport function useWidgetState<T extends UnknownObject>(\n  defaultState?: T | (() => T | null) | null\n): readonly [T | null, (state: SetStateAction<T | null>) => void] {\n  const widgetStateFromWindow = useOpenAiGlobal(\"widgetState\") as T;\n\n  const [widgetState, _setWidgetState] = useState<T | null>(() => {\n    if (widgetStateFromWindow != null) {\n      return widgetStateFromWindow;\n    }\n\n    return typeof defaultState === \"function\" ? defaultState() : defaultState ?? null;\n  });\n\n  useEffect(() => {\n    _setWidgetState(widgetStateFromWindow);\n  }, [widgetStateFromWindow]);\n\n  const setWidgetState = useCallback(\n    (state: SetStateAction<T | null>) => {\n      _setWidgetState((prevState) => {\n        const newState = typeof state === \"function\" ? state(prevState) : state;\n\n        if (newState != null) {\n          void window.openai.setWidgetState(newState);\n        }\n\n        return newState;\n      });\n    },\n    [window.openai.setWidgetState]\n  );\n\n  return [widgetState, setWidgetState] as const;\n}\n"]}