{"version":3,"file":"operationRunners.js","sourceRoot":"","sources":["../../src/operationRunners.ts"],"names":[],"mappings":"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","sourcesContent":["import { filter, pipe, take, toAsyncIterable, toPromise } from \"wonka\";\nimport type { BackgroundActionResult, BackgroundActionResultData } from \"./BackgroundActionHandle.js\";\nimport { BackgroundActionHandle } from \"./BackgroundActionHandle.js\";\n/* eslint-disable @typescript-eslint/ban-types */\nimport type { OperationResult } from \"@urql/core\";\nimport type { Source } from \"wonka\";\nimport type { FieldSelection } from \"./FieldSelection.js\";\nimport type { GadgetConnection } from \"./GadgetConnection.js\";\nimport type {\n  ActionFunctionMetadata,\n  AnyActionFunction,\n  AnyBulkActionFunction,\n  GlobalActionFunction,\n  HasReturnType,\n} from \"./GadgetFunctions.js\";\nimport type { GadgetRecord, RecordShape } from \"./GadgetRecord.js\";\nimport { GadgetRecordList } from \"./GadgetRecordList.js\";\nimport type { AnyModelManager } from \"./ModelManager.js\";\nimport {\n  actionOperation,\n  backgroundActionResultOperation,\n  enqueueActionOperation,\n  findManyOperation,\n  findOneByFieldOperation,\n  findOneOperation,\n  globalActionOperation,\n} from \"./operationBuilders.js\";\nimport {\n  GadgetErrorGroup,\n  GadgetNotFoundError,\n  assertMutationSuccess,\n  assertNullableOperationSuccess,\n  assertOperationSuccess,\n  assertResponseSuccess,\n  disambiguateActionVariables,\n  disambiguateBulkActionVariables,\n  gadgetErrorFor,\n  get,\n  getNonUniqueDataError,\n  hydrateConnection,\n  hydrateRecord,\n  hydrateRecordArray,\n  namespaceDataPath,\n  setVariableOptionValues,\n} from \"./support.js\";\nimport type { ActionFunctionOptions, BaseFindOptions, EnqueueBackgroundActionOptions, FindManyOptions, VariablesOptions } from \"./types.js\";\n\ntype LiveResultForOptions<T, LiveOptions extends { live?: boolean | null }> = LiveOptions extends { live: true }\n  ? AsyncIterable<T>\n  : Promise<T>;\n\nconst mapAsyncIterable = <T, U>(source: AsyncIterable<T>, mapper: (item: T) => U): AsyncIterable<U> => {\n  return {\n    [Symbol.asyncIterator]() {\n      const iter = source[Symbol.asyncIterator]();\n\n      return {\n        async next(): Promise<IteratorResult<U>> {\n          const { done, value } = await iter.next();\n\n          return {\n            done,\n            value: typeof value != \"undefined\" ? mapper(value) : undefined,\n          } as any;\n        },\n        async return(value: any): Promise<IteratorReturnResult<any>> {\n          return (await iter.return?.(value)) as any;\n        },\n      };\n    },\n  };\n};\n\n/** Given a stream, return an async iterable when live querying, and a promise resolving to the last value otherwise */\nfunction maybeLiveStream<T extends OperationResult, U, LiveOptions extends { live?: boolean | null }>(\n  $result: Source<T>,\n  mapper: (value: T) => U,\n  options?: LiveOptions | null\n): LiveResultForOptions<U, LiveOptions> {\n  if (options?.live) {\n    return mapAsyncIterable<T, U>(toAsyncIterable($result), mapper) as unknown as LiveResultForOptions<U, LiveOptions>;\n  } else {\n    const promise = pipe(\n      $result,\n      filter((result) => !result.stale && !result.hasNext),\n      take(1),\n      toPromise\n    );\n\n    return promise.then((value) => mapper(value)) as LiveResultForOptions<U, LiveOptions>;\n  }\n}\n\nexport const findOneRunner = <Shape extends RecordShape = any, Options extends BaseFindOptions = {}>(\n  modelManager: { connection: GadgetConnection },\n  operation: string,\n  id: string | undefined,\n  defaultSelection: FieldSelection,\n  modelApiIdentifier: string,\n  options?: Options | null,\n  throwOnEmptyData = true,\n  namespace?: string | string[] | null\n) => {\n  const plan = findOneOperation(operation, id, defaultSelection, modelApiIdentifier, options, namespace);\n  const $results = modelManager.connection.currentClient.query(plan.query, plan.variables);\n\n  return maybeLiveStream(\n    $results,\n    (response) => {\n      const assertSuccess = throwOnEmptyData ? assertOperationSuccess : assertNullableOperationSuccess;\n      const dataPath = namespaceDataPath([operation], namespace);\n      const record = assertSuccess(response, dataPath);\n      return hydrateRecord<Shape>(response, record);\n    },\n    options\n  );\n};\n\nexport const findOneByFieldRunner = <Shape extends RecordShape = any, Options extends FindManyOptions = {}>(\n  modelManager: { connection: GadgetConnection },\n  operation: string,\n  fieldName: string,\n  fieldValue: string,\n  defaultSelection: FieldSelection,\n  modelApiIdentifier: string,\n  options?: Options | null,\n  throwOnEmptyData = true,\n  namespace?: string | string[] | null\n) => {\n  const plan = findOneByFieldOperation(operation, fieldName, fieldValue, defaultSelection, modelApiIdentifier, options, namespace);\n  const dataPath = namespaceDataPath([operation], namespace);\n  const $results = modelManager.connection.currentClient.query(plan.query, plan.variables);\n\n  return maybeLiveStream(\n    $results,\n    (response) => {\n      const connectionObject = assertOperationSuccess(response, dataPath);\n      const records = hydrateConnection<Shape>(response, connectionObject);\n\n      if (records.length > 1) {\n        throw getNonUniqueDataError(modelApiIdentifier, fieldName, fieldValue);\n      }\n      const result = records[0];\n      if (!result && throwOnEmptyData) {\n        throw new GadgetNotFoundError(`${modelApiIdentifier} record with ${fieldName}=${fieldValue} not found`);\n      }\n      return result ?? null;\n    },\n    options\n  );\n};\n\nexport const findManyRunner = <Shape extends RecordShape = any, Options extends FindManyOptions = {}>(\n  modelManager: AnyModelManager,\n  operation: string,\n  defaultSelection: FieldSelection,\n  modelApiIdentifier: string,\n  options?: Options,\n  throwOnEmptyData?: boolean,\n  namespace?: string | string[] | null\n) => {\n  const plan = findManyOperation(operation, defaultSelection, modelApiIdentifier, options, namespace);\n  const $results = modelManager.connection.currentClient.query(plan.query, plan.variables);\n  const dataPath = namespaceDataPath([operation], namespace);\n\n  return maybeLiveStream(\n    $results,\n    (response) => {\n      let connectionObject;\n      if (throwOnEmptyData === false) {\n        // If this is a nullable operation, don't throw errors on empty\n        connectionObject = assertNullableOperationSuccess(response, dataPath);\n      } else {\n        // Otherwise, passthrough the `throwOnEmptyData` flag, to account for\n        // `findMany` (allows empty arrays) vs `findFirst` (no empty result) usage.\n        connectionObject = assertOperationSuccess(response, dataPath, throwOnEmptyData);\n      }\n\n      const records = hydrateConnection<Shape>(response, connectionObject);\n      return GadgetRecordList.boot<Shape>(modelManager, records, { options, pageInfo: connectionObject.pageInfo });\n    },\n    options\n  );\n};\n\nexport interface ActionRunner {\n  (\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: false,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | string[] | null,\n    hasReturnType?: HasReturnType\n  ): Promise<any>;\n\n  <Shape extends RecordShape = any>(\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: false,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | string[] | null,\n    hasReturnType?: false | null\n  ): Promise<Shape extends void ? void : GadgetRecord<Shape>>;\n\n  <Shape extends RecordShape = any>(\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: false,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | string[] | null\n  ): Promise<Shape extends void ? void : GadgetRecord<Shape>>;\n\n  <Shape extends RecordShape = any>(\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: true,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | string[] | null\n  ): Promise<Shape extends void ? void : GadgetRecord<Shape>[]>;\n\n  (\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: true,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | string[] | null,\n    hasReturnType?: HasReturnType\n  ): Promise<any[]>;\n\n  <Shape extends RecordShape = any>(\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: true,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | string[] | null,\n    hasReturnType?: false | null\n  ): Promise<Shape extends void ? void : GadgetRecord<Shape>[]>;\n}\n\nexport const actionRunner: ActionRunner = async (\n  modelManager: { connection: GadgetConnection },\n  operation: string,\n  defaultSelection: FieldSelection | null,\n  modelApiIdentifier: string,\n  modelSelectionField: string,\n  isBulkAction: boolean,\n  variables: VariablesOptions,\n  options?: BaseFindOptions | null,\n  namespace?: string | string[] | null,\n  hasReturnType?: HasReturnType | null\n) => {\n  const plan = actionOperation(\n    operation,\n    defaultSelection,\n    modelApiIdentifier,\n    modelSelectionField,\n    variables,\n    options,\n    namespace,\n    isBulkAction,\n    hasReturnType\n  );\n\n  const response = await modelManager.connection.currentClient.mutation(plan.query, plan.variables).toPromise();\n  const dataPath = namespaceDataPath([operation], namespace);\n\n  // pass bulk responses through without any assertions since we can have a success: false response but still want\n  // to process it in a similar fashion since some of the records could have been processed\n  if (!isBulkAction) {\n    const mutationTriple = assertMutationSuccess(response, dataPath);\n\n    return processActionResponse(defaultSelection, response, mutationTriple, modelSelectionField, hasReturnType);\n  } else {\n    const mutationTriple = get(response.data, dataPath);\n\n    const results = processBulkActionResponse(defaultSelection, response, mutationTriple, modelSelectionField, hasReturnType);\n    if (mutationTriple.errors) {\n      const errors = mutationTriple.errors.map((error: any) => gadgetErrorFor(error));\n      throw new GadgetErrorGroup(errors, results);\n    }\n\n    return results;\n  }\n};\n\nconst processBulkActionResponse = <Shape extends RecordShape = any>(\n  defaultSelection: FieldSelection | null,\n  response: any,\n  records: any,\n  modelSelectionField: string,\n  hasReturnType?: HasReturnType | null\n) => {\n  if (defaultSelection == null) return;\n  if (!hasReturnType) {\n    return hydrateRecordArray<Shape>(response, records[modelSelectionField]);\n  } else if (typeof hasReturnType == \"boolean\") {\n    return records.results;\n  } else {\n    return Object.entries(hasReturnType).flatMap(([returnTypeField, innerHasReturnType]) => {\n      const results = records[returnTypeField];\n\n      if (!Array.isArray(results)) {\n        return [];\n      }\n\n      return results.map((result) => {\n        const returnTypeForResult =\n          \"hasReturnType\" in innerHasReturnType ? returnTypeForRecord(result, innerHasReturnType.hasReturnType) : false;\n\n        if (!returnTypeForResult) {\n          return hydrateRecord<Shape>(response, result);\n        } else {\n          return processActionResponse(defaultSelection, response, result, modelSelectionField, returnTypeForResult);\n        }\n      });\n    });\n  }\n};\n\nexport const processActionResponse = <Shape extends RecordShape = any>(\n  defaultSelection: FieldSelection | null,\n  response: any,\n  record: any,\n  modelSelectionField: string,\n  hasReturnType?: HasReturnType | null\n): any => {\n  // Delete actions have a null selection. We do an early return for this because `hydrateRecordArray` will fail\n  // if there's nothing at `mutationResult[modelSelectionField]`, but the caller isn't expecting a return (void).\n  if (defaultSelection == null) return;\n  if (!hasReturnType) {\n    return hydrateRecord<Shape>(response, record[modelSelectionField]);\n  } else if (typeof hasReturnType == \"boolean\") {\n    return record.result;\n  } else {\n    const innerReturnType = returnTypeForRecord(record, hasReturnType);\n\n    return processActionResponse(defaultSelection, response, record, modelSelectionField, innerReturnType);\n  }\n};\n\nconst returnTypeForRecord = (record: any, hasReturnType: HasReturnType) => {\n  if (typeof hasReturnType == \"boolean\") {\n    return hasReturnType;\n  }\n\n  const innerReturnTypeForTypename = hasReturnType[`... on ${record.__typename}`];\n\n  return innerReturnTypeForTypename && \"hasReturnType\" in innerReturnTypeForTypename ? innerReturnTypeForTypename.hasReturnType : false;\n};\n\nexport const globalActionRunner = async (\n  connection: GadgetConnection,\n  operation: string,\n  variables: VariablesOptions,\n  namespace?: string | string[] | null\n) => {\n  const plan = globalActionOperation(operation, variables, namespace);\n  const response = await connection.currentClient.mutation(plan.query, plan.variables).toPromise();\n  const dataPath = namespaceDataPath([operation], namespace);\n  return assertMutationSuccess(response, dataPath).result;\n};\n\nexport async function enqueueActionRunner<SchemaT, Action extends AnyBulkActionFunction, Result = BackgroundActionHandle<SchemaT, Action>>(\n  connection: GadgetConnection,\n  action: Action,\n  variables: Action[\"variablesType\"],\n  options?: EnqueueBackgroundActionOptions<Action>\n): Promise<Result[]>;\nexport async function enqueueActionRunner<SchemaT, Action extends AnyActionFunction, Result = BackgroundActionHandle<SchemaT, Action>>(\n  connection: GadgetConnection,\n  action: Action,\n  variables: Action[\"variablesType\"],\n  options?: EnqueueBackgroundActionOptions<Action>\n): Promise<Result>;\nexport async function enqueueActionRunner<SchemaT, Action extends AnyActionFunction, Result = BackgroundActionHandle<SchemaT, Action>>(\n  connection: GadgetConnection,\n  action: Action,\n  variables: Action[\"variablesType\"],\n  options: EnqueueBackgroundActionOptions<Action> = {}\n): Promise<Result | Result[]> {\n  const normalizedVariableValues = action.isBulk\n    ? disambiguateBulkActionVariables(action, variables)\n    : disambiguateActionVariables(action, variables);\n  const variableOptions = setVariableOptionValues(action.variables, normalizedVariableValues);\n\n  const plan = enqueueActionOperation(action.operationName, variableOptions, action.namespace, options, action.isBulk);\n  const response = await connection.currentClient.mutation(plan.query, plan.variables, options).toPromise();\n  const dataPath = [\"background\", ...namespaceDataPath([action.operationName], action.namespace)];\n\n  try {\n    const result = assertMutationSuccess(response, dataPath);\n    if (action.isBulk) {\n      return result.backgroundActions.map((result: { id: string }) => new BackgroundActionHandle(connection, action, result.id));\n    } else {\n      return new BackgroundActionHandle(connection, action, result.backgroundAction.id) as Result;\n    }\n  } catch (error: any) {\n    if (\"code\" in error && error.code == \"GGT_DUPLICATE_BACKGROUND_ACTION_ID\" && options?.id && options.onDuplicateID == \"ignore\") {\n      return new BackgroundActionHandle(connection, action, options.id) as Result;\n    }\n    throw error;\n  }\n}\n\nexport const backgroundActionResultRunner = async <\n  SchemaT,\n  Action extends ActionFunctionMetadata<any, any, any, SchemaT, any, any> | GlobalActionFunction<any>,\n  Options extends ActionFunctionOptions<Action>,\n  ResultData = BackgroundActionResultData<Action, Options>\n>(\n  connection: GadgetConnection,\n  id: string,\n  action: Action,\n  options?: Options\n): Promise<BackgroundActionResult<ResultData>> => {\n  const plan = backgroundActionResultOperation(id, action, options);\n  const subscription = connection.currentClient.subscription(plan.query, plan.variables);\n\n  const response = await pipe(\n    subscription,\n    filter((operation) => operation.error || operation.data?.backgroundAction?.outcome),\n    take(1),\n    toPromise\n  );\n\n  const backgroundAction = assertOperationSuccess(response, [\"backgroundAction\"]);\n\n  assertResponseSuccess(backgroundAction.result);\n\n  switch (action.type) {\n    case \"action\": {\n      backgroundAction.result = processActionResponse(\n        action.defaultSelection,\n        response.data,\n        backgroundAction.result,\n        action.isBulk ? action.modelApiIdentifier : action.modelSelectionField,\n        action.hasReturnType\n      );\n      break;\n    }\n    case \"globalAction\": {\n      backgroundAction.result = backgroundAction.result.result;\n      break;\n    }\n  }\n\n  return backgroundAction as BackgroundActionResult<ResultData>;\n};\n\n/** @deprecated previous export name, @see backgroundActionResultRunner */\nexport const actionResultRunner = backgroundActionResultRunner;\n"]}