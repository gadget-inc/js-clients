{"version":3,"file":"useFindBy.js","sourceRoot":"","sources":["../../src/useFindBy.ts"],"names":[],"mappings":";;;AACA,gEAAyI;AACzI,iCAAgC;AAChC,qDAAkD;AAClD,2DAAwD;AAExD,mCAAqD;AAErD;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACI,MAAM,SAAS,GAAG,CAMvB,MAAS,EACT,KAAa,EACb,OAA4E,EAG5E,EAAE;IACF,MAAM,eAAe,GAAG,IAAA,qCAAiB,EAAC,OAAO,CAAC,CAAC;IACnD,MAAM,IAAI,GAAG,IAAA,eAAO,EAAC,GAAG,EAAE;QACxB,OAAO,IAAA,yCAAuB,EAC5B,MAAM,CAAC,aAAa,EACpB,MAAM,CAAC,kBAAkB,EACzB,KAAK,EACL,MAAM,CAAC,gBAAgB,EACvB,MAAM,CAAC,kBAAkB,EACzB,eAAe,CAChB,CAAC;IACJ,CAAC,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,eAAe,CAAC,CAAC,CAAC;IAErC,MAAM,CAAC,SAAS,EAAE,OAAO,CAAC,GAAG,IAAA,+BAAc,EAAC,IAAA,oBAAY,EAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC;IAEzE,MAAM,MAAM,GAAG,IAAA,eAAO,EAAC,GAAG,EAAE;QAC1B,MAAM,QAAQ,GAAG,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;QAExC,IAAI,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;QAC1B,IAAI,OAAO,GAAG,EAAE,CAAC;QACjB,IAAI,IAAI,EAAE;YACR,MAAM,UAAU,GAAG,IAAA,qBAAG,EAAC,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;YACjD,IAAI,UAAU,EAAE;gBACd,OAAO,GAAG,IAAA,mCAAiB,EAAC,SAAS,EAAE,UAAU,CAAC,CAAC;gBACnD,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;aACnB;SACF;QAED,IAAI,KAAK,GAAG,oBAAY,CAAC,qBAAqB,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QAChE,IAAI,CAAC,KAAK,EAAE;YACV,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;gBACtB,KAAK,GAAG,oBAAY,CAAC,kBAAkB,CAAC,IAAA,uCAAqB,EAAC,MAAM,CAAC,kBAAkB,EAAE,MAAM,CAAC,kBAAkB,EAAE,KAAK,CAAC,CAAC,CAAC;aAC7H;iBAAM,IAAI,SAAS,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;gBACxC,KAAK,GAAG,oBAAY,CAAC,kBAAkB,CACrC,IAAI,qCAAmB,CAAC,GAAG,MAAM,CAAC,kBAAkB,gBAAgB,MAAM,CAAC,kBAAkB,IAAI,KAAK,YAAY,CAAC,CACpH,CAAC;aACH;SACF;QAED,OAAO,EAAE,GAAG,SAAS,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;IACvC,CAAC,EAAE,CAAC,SAAS,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;IAE/B,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAC3B,CAAC,CAAC;AAtDW,QAAA,SAAS,aAsDpB","sourcesContent":["import type { DefaultSelection, FindOneFunction, GadgetRecord, LimitToKnownKeys, Select } from \"@gadgetinc/api-client-core\";\nimport { GadgetNotFoundError, findOneByFieldOperation, get, getNonUniqueDataError, hydrateConnection } from \"@gadgetinc/api-client-core\";\nimport { useMemo } from \"react\";\nimport { useGadgetQuery } from \"./useGadgetQuery\";\nimport { useStructuralMemo } from \"./useStructuralMemo\";\nimport type { OptionsType, ReadHookResult, ReadOperationOptions } from \"./utils\";\nimport { ErrorWrapper, useQueryArgs } from \"./utils\";\n\n/**\n * React hook to fetch a Gadget record using the `findByXYZ` method of a given model manager. Useful for finding records by key fields which are used for looking up records by. Gadget autogenerates the `findByXYZ` methods on your model managers, and `useFindBy` can only be used with models that have these generated finder functions.\n *\n * @param finder `findByXYZ` function from a Gadget manager that will be used\n * @param value field value of the record to fetch\n * @param options options for selecting the fields in the result\n *\n * @example\n * ```\n * export function UserByEmail(props: { email: string }) {\n *   const [result, refresh] = useFindBy(api.user.findByEmail, props.email, {\n *     select: {\n *       name: true,\n *     },\n *   });\n *\n *   if (result.error) return <>Error: {result.error.toString()}</>;\n *   if (result.fetching && !result.data) return <>Fetching...</>;\n *   if (!result.data) return <>No user found with id={props.id}</>;\n *\n *   return <div>{result.data.name}</div>;\n * }\n */\nexport const useFindBy = <\n  GivenOptions extends OptionsType, // currently necessary for Options to be a narrow type (e.g., `true` instead of `boolean`)\n  SchemaT,\n  F extends FindOneFunction<GivenOptions, any, SchemaT, any>,\n  Options extends F[\"optionsType\"] & ReadOperationOptions\n>(\n  finder: F,\n  value: string,\n  options?: LimitToKnownKeys<Options, F[\"optionsType\"] & ReadOperationOptions>\n): ReadHookResult<\n  GadgetRecord<Select<Exclude<F[\"schemaType\"], null | undefined>, DefaultSelection<F[\"selectionType\"], Options, F[\"defaultSelection\"]>>>\n> => {\n  const memoizedOptions = useStructuralMemo(options);\n  const plan = useMemo(() => {\n    return findOneByFieldOperation(\n      finder.operationName,\n      finder.findByVariableName,\n      value,\n      finder.defaultSelection,\n      finder.modelApiIdentifier,\n      memoizedOptions\n    );\n  }, [finder, value, memoizedOptions]);\n\n  const [rawResult, refresh] = useGadgetQuery(useQueryArgs(plan, options));\n\n  const result = useMemo(() => {\n    const dataPath = [finder.operationName];\n\n    let data = rawResult.data;\n    let records = [];\n    if (data) {\n      const connection = get(rawResult.data, dataPath);\n      if (connection) {\n        records = hydrateConnection(rawResult, connection);\n        data = records[0];\n      }\n    }\n\n    let error = ErrorWrapper.forMaybeCombinedError(rawResult.error);\n    if (!error) {\n      if (records.length > 1) {\n        error = ErrorWrapper.forClientSideError(getNonUniqueDataError(finder.modelApiIdentifier, finder.findByVariableName, value));\n      } else if (rawResult.data && !records[0]) {\n        error = ErrorWrapper.forClientSideError(\n          new GadgetNotFoundError(`${finder.modelApiIdentifier} record with ${finder.findByVariableName}=${value} not found`)\n        );\n      }\n    }\n\n    return { ...rawResult, data, error };\n  }, [rawResult, finder, value]);\n\n  return [result, refresh];\n};\n"]}