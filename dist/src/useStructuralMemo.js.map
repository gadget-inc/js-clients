{"version":3,"file":"useStructuralMemo.js","sourceRoot":"","sources":["../../src/useStructuralMemo.ts"],"names":[],"mappings":";;;;;;AAAA,4DAAmC;AACnC,iCAA+B;AAE/B;;GAEG;AACI,MAAM,iBAAiB,GAAG,CAAI,KAAQ,EAAK,EAAE;IAClD,MAAM,GAAG,GAAG,IAAA,cAAM,GAAK,CAAC;IACxB,IAAI,KAAK,EAAE;QACT,IAAI,GAAG,CAAC,OAAO,KAAK,SAAS,IAAI,CAAC,IAAA,oBAAS,EAAC,KAAK,EAAE,GAAG,CAAC,OAAO,CAAC,EAAE;YAC/D,GAAG,CAAC,OAAO,GAAG,KAAK,CAAC;SACrB;KACF;SAAM;QACL,GAAG,CAAC,OAAO,GAAG,SAAS,CAAC;KACzB;IAED,OAAO,GAAG,CAAC,OAAY,CAAC;AAC1B,CAAC,CAAC;AAXW,QAAA,iBAAiB,qBAW5B","sourcesContent":["import deepEqual from \"deep-equal\";\nimport { useRef } from \"react\";\n\n/**\n * Memoize and ensure a stable identity on a given value as long as it remains the same, structurally.\n */\nexport const useStructuralMemo = <T>(value: T): T => {\n  const ref = useRef<T>();\n  if (value) {\n    if (ref.current === undefined || !deepEqual(value, ref.current)) {\n      ref.current = value;\n    }\n  } else {\n    ref.current = undefined;\n  }\n\n  return ref.current as T;\n};\n"]}