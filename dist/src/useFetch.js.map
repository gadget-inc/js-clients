{"version":3,"file":"useFetch.js","sourceRoot":"","sources":["../../src/useFetch.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Reducer } from \"react\";\nimport { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport { useConnection } from \"./GadgetProvider\";\nimport { useStructuralMemo } from \"./useStructuralMemo\";\nimport { ErrorWrapper } from \"./utils\";\n\nexport interface FetchHookState<T> {\n  data?: T;\n  response?: Response;\n  error?: ErrorWrapper;\n  fetching: boolean;\n  options: FetchHookOptions;\n}\n\nexport type FetchHookResult<T> = [FetchHookState<T>, (opts?: Partial<FetchHookOptions>) => Promise<T>];\n\ntype FetchAction<T> = { type: \"fetching\" } | { type: \"fetched\"; payload: T } | { type: \"error\"; payload: ErrorWrapper };\n\nconst reducer = <T>(state: FetchHookState<T>, action: FetchAction<T>): FetchHookState<T> => {\n  switch (action.type) {\n    case \"fetching\":\n      return { ...state, fetching: true, error: undefined };\n    case \"fetched\":\n      return { ...state, fetching: false, data: action.payload, error: undefined };\n    case \"error\":\n      return { ...state, fetching: false, error: action.payload };\n    default:\n      return state;\n  }\n};\n\nexport interface FetchHookOptions extends RequestInit {\n  stream?: boolean;\n  json?: boolean;\n  sendImmediately?: boolean;\n}\n\nconst startRequestByDefault = (options?: FetchHookOptions) => {\n  if (typeof options?.sendImmediately != \"undefined\") {\n    return options.sendImmediately;\n  } else {\n    return !options?.method || options.method === \"GET\";\n  }\n};\n\n/**\n * React hook to make an HTTP request to a Gadget backend HTTP route. Preserves client side session information and ensures it's passed along to the backend.\n *\n * Returns a tuple with the current state of the request and a function to send or re-send the request. The state is an object with the following fields:\n * - `data`: the response data, if the request was successful\n * - `fetching`: a boolean describing if the fetch request is currently in progress\n * - `error`: an error object if the request failed in any way\n *\n * The second return value is a function for executing the fetch request. It returns a promise for the response body.\n *\n * By default, `GET` requests are sent as soon as the hook executes. Any other request methods are not sent automatically, and must be triggered by calling the `execute` function returned in the second argument.\n *\n * Pass the `{ json: true }` option to expect a JSON response from the server, and to automatically parse the response as JSON. Otherwise, the response will be returned as a `string` object.\n *\n * Pass the `{ stream: true }` to get a `ReadableStream` object as a response from the server, allowing you to work with the response as it arrives. Otherwise, the response will be returned as a `string` object.\n *\n * If you want to read model data, see the `useFindMany` function and similar. If you want to invoke a backend Action, use the `useAction` hook instead.\n *\n * @param path the backend path to fetch\n * @param options the `fetch` options for the request\n *\n * @example\n * ```\n * export function UserByEmail(props: { email: string }) {\n *   const [{data, fetching, error}, refresh] = useFetch(\"/users/get\", {\n *     method: \"GET\",\n *     body: JSON.stringify({ email: props.email }})\n *     headers: {\n *       \"content-type\": \"application/json\",\n *     }\n *     json: true,\n *   });\n *\n *   if (result.error) return <>Error: {result.error.toString()}</>;\n *   if (result.fetching && !result.data) return <>Fetching...</>;\n *   if (!result.data) return <>No user found with id={props.id}</>;\n *\n *   return <div>{result.data.name}</div>;\n * }\n */\nexport function useFetch(path: string, options: { stream: true } & FetchHookOptions): FetchHookResult<ReadableStream<Uint8Array>>;\nexport function useFetch<T extends Record<string, any>>(url: string, options: { json: true } & FetchHookOptions): FetchHookResult<T>;\nexport function useFetch(path: string, options?: FetchHookOptions): FetchHookResult<string>;\nexport function useFetch<T = string>(path: string, options?: FetchHookOptions): FetchHookResult<T> {\n  // Used to prevent state update if the component is unmounted\n  const mounted = useRef<boolean>(true);\n  const memoizedOptions = useStructuralMemo<FetchHookOptions>(options ?? {});\n  const connection = useConnection();\n  const startRequestOnMount = startRequestByDefault(memoizedOptions);\n\n  const [state, dispatch] = useReducer<Reducer<FetchHookState<T>, FetchAction<T>>, FetchHookOptions>(\n    reducer,\n    memoizedOptions,\n    (memoizedOptions) => {\n      return { fetching: startRequestOnMount, options: memoizedOptions };\n    }\n  );\n\n  const send = useCallback(\n    async (sendOptions?: Partial<FetchHookOptions>): Promise<T> => {\n      dispatch({ type: \"fetching\" });\n\n      let data: any;\n      let response: Response | undefined = undefined;\n\n      const mergedOptions = { ...memoizedOptions, ...sendOptions };\n      if (mergedOptions.json) {\n        mergedOptions.headers ??= {};\n        (mergedOptions.headers as any)[\"accept\"] ??= \"application/json\";\n      }\n\n      try {\n        const { json: _json, stream: _stream, ...fetchOptions } = mergedOptions;\n        // make the fetch call using GadgetConnection to pass along auth and other headers\n        response = await connection.fetch(path, fetchOptions);\n        if (!response.ok) {\n          throw new Error(response.statusText);\n        }\n\n        if (mergedOptions.json) {\n          data = await response.json();\n        } else if (mergedOptions.stream) {\n          data = response.body;\n        } else {\n          data = await response.text();\n        }\n\n        if (!mounted.current) return data;\n\n        dispatch({ type: \"fetched\", payload: data });\n      } catch (error: any) {\n        if (!mounted.current) return null as any;\n\n        const wrapped = ErrorWrapper.forClientSideError(error, response);\n        dispatch({ type: \"error\", payload: wrapped });\n        throw wrapped;\n      }\n      return data;\n    },\n    [memoizedOptions, path]\n  );\n\n  useEffect(() => {\n    mounted.current = true;\n    if (startRequestOnMount) {\n      void send().catch(() => {\n        // report error via return state\n      });\n    }\n\n    return () => {\n      mounted.current = false;\n    };\n  }, [path, startRequestOnMount, send]);\n\n  return [state, send];\n}\n"]}