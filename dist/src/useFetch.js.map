{"version":3,"file":"useFetch.js","sourceRoot":"","sources":["../../src/useFetch.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Reducer } from \"react\";\nimport { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport { useConnection } from \"./GadgetProvider\";\nimport { useStructuralMemo } from \"./useStructuralMemo\";\nimport { ErrorWrapper } from \"./utils\";\n\nexport interface FetchHookState<T> {\n  data?: T;\n  response?: Response;\n  error?: ErrorWrapper;\n  fetching: boolean;\n  options: FetchHookOptions;\n}\n\nexport type FetchHookResult<T, U = T> = [FetchHookState<T>, (opts?: Partial<FetchHookOptions>) => Promise<U>];\n\ntype FetchAction<T> =\n  | { type: \"fetching\" }\n  | { type: \"fetched\"; payload: T }\n  | { type: \"update\"; payload: T }\n  | { type: \"error\"; payload: ErrorWrapper };\n\nconst reducer = <T>(state: FetchHookState<T>, action: FetchAction<T>): FetchHookState<T> => {\n  switch (action.type) {\n    case \"fetching\":\n      return { ...state, fetching: true, error: undefined };\n    case \"fetched\":\n      return { ...state, fetching: false, data: action.payload, error: undefined };\n    case \"update\":\n      return { ...state, data: action.payload };\n    case \"error\":\n      return { ...state, fetching: false, error: action.payload };\n    default:\n      return state;\n  }\n};\n\nexport interface FetchHookOptions extends RequestInit {\n  stream?: boolean | string;\n  json?: boolean;\n  sendImmediately?: boolean;\n}\n\nconst startRequestByDefault = (options?: FetchHookOptions) => {\n  if (typeof options?.sendImmediately != \"undefined\") {\n    return options.sendImmediately;\n  } else {\n    return !options?.method || options.method === \"GET\";\n  }\n};\n\nconst dispatchError = (\n  mounted: React.MutableRefObject<boolean>,\n  dispatch: React.Dispatch<FetchAction<any>>,\n  error: any,\n  response?: Response\n) => {\n  if (!mounted.current) return null;\n\n  const wrapped = ErrorWrapper.forClientSideError(error, response);\n  dispatch({ type: \"error\", payload: wrapped });\n\n  return wrapped;\n};\n\n/**\n * React hook to make an HTTP request to a Gadget backend HTTP route. Preserves client side session information and ensures it's passed along to the backend.\n *\n * Returns a tuple with the current state of the request and a function to send or re-send the request. The state is an object with the following fields:\n * - `data`: the response data, if the request was successful\n * - `fetching`: a boolean describing if the fetch request is currently in progress\n * - `error`: an error object if the request failed in any way\n *\n * The second return value is a function for executing the fetch request. It returns a promise for the response body.\n *\n * By default, `GET` requests are sent as soon as the hook executes. Any other request methods are not sent automatically, and must be triggered by calling the `execute` function returned in the second argument.\n *\n * Pass the `{ json: true }` option to expect a JSON response from the server, and to automatically parse the response as JSON. Otherwise, the response will be returned as a `string` object.\n *\n * Pass the `{ stream: true }` to get a `ReadableStream` object as a response from the server, allowing you to work with the response as it arrives.\n *\n * Pass the `{ stream: \"string\" }` to decode the `ReadableStream` as a string and update data as it arrives. If the stream is in an encoding other than utf8 use i.e. `{ stream: \"utf-16\" }`.\n *\n * If you want to read model data, see the `useFindMany` function and similar. If you want to invoke a backend Action, use the `useAction` hook instead.\n *\n * @param path the backend path to fetch\n * @param options the `fetch` options for the request\n *\n * @example\n * ```\n * export function UserByEmail(props: { email: string }) {\n *   const [{data, fetching, error}, refresh] = useFetch(\"/users/get\", {\n *     method: \"GET\",\n *     body: JSON.stringify({ email: props.email }})\n *     headers: {\n *       \"content-type\": \"application/json\",\n *     }\n *     json: true,\n *   });\n *\n *   if (result.error) return <>Error: {result.error.toString()}</>;\n *   if (result.fetching && !result.data) return <>Fetching...</>;\n *   if (!result.data) return <>No user found with id={props.id}</>;\n *\n *   return <div>{result.data.name}</div>;\n * }\n */\nexport function useFetch(path: string, options: { stream: string } & FetchHookOptions): FetchHookResult<string, ReadableStream<string>>;\nexport function useFetch(path: string, options: { stream: true } & FetchHookOptions): FetchHookResult<ReadableStream<Uint8Array>>;\nexport function useFetch<T extends Record<string, any>>(url: string, options: { json: true } & FetchHookOptions): FetchHookResult<T>;\nexport function useFetch(path: string, options?: FetchHookOptions): FetchHookResult<string>;\nexport function useFetch<T = string>(path: string, options?: FetchHookOptions): FetchHookResult<T> {\n  // Used to prevent state update if the component is unmounted\n  const mounted = useRef<boolean>(true);\n  const memoizedOptions = useStructuralMemo<FetchHookOptions>(options ?? {});\n  const connection = useConnection();\n  const startRequestOnMount = startRequestByDefault(memoizedOptions);\n  const controller = useRef<AbortController | null>(null);\n\n  const [state, dispatch] = useReducer<Reducer<FetchHookState<T>, FetchAction<T>>, FetchHookOptions>(\n    reducer,\n    memoizedOptions,\n    (memoizedOptions) => {\n      return { fetching: startRequestOnMount, options: memoizedOptions };\n    }\n  );\n\n  const send = useCallback(\n    async (sendOptions?: Partial<FetchHookOptions>): Promise<T> => {\n      controller.current?.abort(\"useFetch is starting a new request\");\n\n      const abortContoller = new AbortController();\n      controller.current = abortContoller;\n\n      dispatch({ type: \"fetching\" });\n\n      let data: any;\n      let response: Response | undefined = undefined;\n\n      const mergedOptions = { ...memoizedOptions, ...sendOptions };\n      if (mergedOptions.json) {\n        mergedOptions.headers ??= {};\n        (mergedOptions.headers as any)[\"accept\"] ??= \"application/json\";\n      }\n\n      try {\n        const { json: _json, stream: _stream, ...fetchOptions } = mergedOptions;\n        // make the fetch call using GadgetConnection to pass along auth and other headers\n        response = await connection.fetch(path, { signal: abortContoller.signal, ...fetchOptions });\n        if (!response.ok) {\n          throw new Error(response.statusText);\n        }\n\n        let dispatchData = true;\n\n        if (mergedOptions.json) {\n          data = await response.json();\n        } else if (typeof mergedOptions.stream === \"string\") {\n          dispatchData = false;\n          const decodedStream = response.body!.pipeThrough(\n            new TextDecoderStream(mergedOptions.stream === \"string\" ? \"utf8\" : mergedOptions.stream)\n          );\n\n          const [responseStream, updateStream] = decodedStream.tee();\n\n          data = responseStream;\n          const decodedStreamReader = updateStream.getReader();\n\n          decodedStreamReader.closed.catch((error) => {\n            if (!abortContoller.signal.aborted) {\n              dispatchError(mounted, dispatch, error, response);\n            }\n          });\n\n          dispatch({ type: \"fetched\", payload: \"\" as any });\n\n          (async () => {\n            let responseText = \"\";\n            let done = false;\n\n            while (!done) {\n              const { value, done: _done } = await decodedStreamReader.read();\n              done = _done;\n\n              if (value) {\n                responseText += value;\n\n                if (!abortContoller.signal.aborted) {\n                  dispatch({ type: \"update\", payload: responseText as any });\n                }\n              }\n            }\n          })().catch((error) => {\n            if (!abortContoller.signal.aborted) {\n              dispatchError(mounted, dispatch, error, response);\n            }\n          });\n        } else if (mergedOptions.stream) {\n          data = response.body;\n        } else {\n          data = await response.text();\n        }\n\n        if (!mounted.current || !dispatchData) return data;\n\n        dispatch({ type: \"fetched\", payload: data });\n      } catch (error: any) {\n        const wrapped = dispatchError(mounted, dispatch, error, response);\n        if (!wrapped) return null as any;\n        throw wrapped;\n      }\n      return data;\n    },\n    [memoizedOptions, path]\n  );\n\n  useEffect(() => {\n    mounted.current = true;\n    if (startRequestOnMount) {\n      void send().catch(() => {\n        // report error via return state\n      });\n    }\n\n    return () => {\n      mounted.current = false;\n      controller.current?.abort();\n    };\n  }, [path, startRequestOnMount, send]);\n\n  return [state, send];\n}\n"]}