{"version":3,"file":"GadgetConnection.js","sourceRoot":"","sources":["../../src/GadgetConnection.ts"],"names":[],"mappings":"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","sourcesContent":["import { cacheExchange, Client, dedupExchange, subscriptionExchange } from \"@urql/core\";\nimport { multipartFetchExchange } from \"@urql/exchange-multipart-fetch\";\nimport fetch from \"cross-fetch\";\nimport { ExecutionResult } from \"graphql\";\nimport {\n  Client as SubscriptionClient,\n  ClientOptions as SubscriptionClientOptions,\n  CloseCode,\n  createClient as createSubscriptionClient,\n  Sink,\n} from \"graphql-ws\";\nimport WebSocket from \"isomorphic-ws\";\nimport type { AuthenticationModeOptions, BrowserSessionAuthenticationModeOptions } from \"./ClientOptions\";\nimport { BrowserSessionStorageType } from \"./ClientOptions\";\nimport { GadgetTransaction, TransactionRolledBack } from \"./GadgetTransaction\";\nimport { BrowserStorage, InMemoryStorage } from \"./InMemoryStorage\";\nimport { traceFunction } from \"./support\";\n\nexport type TransactionRun<T> = (transaction: GadgetTransaction) => Promise<T>;\nexport interface GadgetSubscriptionClientOptions extends Partial<SubscriptionClientOptions> {\n  urlParams?: Record<string, string | null | undefined>;\n  connectionAttempts?: number;\n  connectionGlobalTimeoutMs?: number;\n}\n\nconst DEFAULT_CONN_ATTEMPTS = 2;\nconst DEFAULT_CONN_ACK_TIMEOUT = 4_800;\nconst DEFAULT_CONN_GLOBAL_TIMEOUT = 10_000;\n\nexport const $transaction = Symbol.for(\"gadget/transaction\");\nconst sessionStorageKey = \"token\";\nconst base64 = typeof btoa !== \"undefined\" ? btoa : (str: string) => Buffer.from(str).toString(\"base64\");\n\nexport interface GadgetConnectionOptions {\n  endpoint: string;\n  authenticationMode?: AuthenticationModeOptions;\n  websocketsEndpoint?: string;\n  subscriptionClientOptions?: GadgetSubscriptionClientOptions;\n  websocketImplementation?: any;\n  fetchImplementation?: typeof fetch;\n  environment?: \"Development\" | \"Production\";\n}\n\nconst isCloseEvent = (event: any): event is CloseEvent => event?.type == \"close\";\n\n/**\n * Represents the current strategy for authenticating with the Gadget platform.\n * For individual users in web browsers, we authenticate using a session token stored client side, like a cookie, but with cross domain support.\n * For server to server communication, or traceable access from the browser, we use pre shared secrets called API Keys\n * And when within the Gadget platform itself, we use a private secret token called an Internal Auth Token. Internal Auth Tokens are managed by Gadget and should never be used by external developers.\n **/\nexport enum AuthenticationMode {\n  BrowserSession = \"browser-session\",\n  APIKey = \"api-key\",\n  InternalAuthToken = \"internal-auth-token\",\n  Anonymous = \"anonymous\",\n}\n\n/**\n * Root level database connection that Actions can use to mutate data in a Gadget database.\n * Manages transactions and the connection to a Gadget API\n */\nexport class GadgetConnection {\n  // Options used when generating new GraphQL clients for the base connection and for for transactions\n  private endpoint: string;\n  private subscriptionClientOptions?: SubscriptionClientOptions;\n  private websocketsEndpoint: string;\n  private websocketImplementation: any;\n  private fetchImplementation: typeof fetch;\n  private environment: \"Development\" | \"Production\";\n\n  // the base client using HTTP requests that non-transactional operations will use\n  private baseClient: Client;\n  private baseSubscriptionClient: SubscriptionClient;\n\n  // the transactional websocket client that will be used inside a transaction block\n  private currentTransaction: GadgetTransaction | null = null;\n\n  // How this client will authenticate (if at all) against the Gadget backed\n  authenticationMode: AuthenticationMode;\n  private sessionTokenStore?: BrowserStorage;\n\n  constructor(readonly options: GadgetConnectionOptions) {\n    if (!options.endpoint) throw new Error(\"Must provide an `endpoint` option for a GadgetConnection to connect to\");\n    this.endpoint = options.endpoint;\n    this.fetchImplementation = options.fetchImplementation ?? fetch;\n    this.websocketImplementation = options.websocketImplementation ?? WebSocket;\n    this.websocketsEndpoint = options.websocketsEndpoint ?? options.endpoint + \"/batch\";\n    this.websocketsEndpoint = this.websocketsEndpoint.replace(/^http/, \"ws\");\n    this.environment = options.environment ?? \"Development\";\n\n    if (options.authenticationMode) {\n      if (options.authenticationMode.browserSession) {\n        this.enableSessionMode(options.authenticationMode.browserSession);\n      } else if (options.authenticationMode.internalAuthToken) {\n        this.authenticationMode = AuthenticationMode.InternalAuthToken;\n      } else if (options.authenticationMode.apiKey) {\n        this.authenticationMode = AuthenticationMode.APIKey;\n      }\n    }\n\n    this.authenticationMode ??= AuthenticationMode.Anonymous;\n\n    // the base client for subscriptions is lazy so we don't open unnecessary connections to the backend, and it reconnects to deal with network issues\n    this.baseSubscriptionClient = this.newSubscriptionClient({ lazy: true });\n    this.baseClient = this.newBaseClient();\n  }\n\n  get currentClient() {\n    return this.currentTransaction?.client || this.baseClient;\n  }\n\n  enableSessionMode(options?: true | BrowserSessionAuthenticationModeOptions) {\n    this.authenticationMode = AuthenticationMode.BrowserSession;\n    if (!options || typeof options == \"boolean\" || options.storageType == BrowserSessionStorageType.Durable) {\n      this.sessionTokenStore = window.localStorage;\n    } else if (options.storageType == BrowserSessionStorageType.Session) {\n      this.sessionTokenStore = window.sessionStorage;\n    } else {\n      this.sessionTokenStore = new InMemoryStorage();\n    }\n    this.resetClients();\n  }\n\n  transaction: {\n    <T>(options: GadgetSubscriptionClientOptions, run: TransactionRun<T>): Promise<T>;\n    <T>(run: TransactionRun<T>): Promise<T>;\n  } = traceFunction(\n    \"api-client.transaction\",\n    async <T>(optionsOrRun: GadgetSubscriptionClientOptions | TransactionRun<T>, maybeRun?: TransactionRun<T>): Promise<T> => {\n      let run: TransactionRun<T>;\n      let options: GadgetSubscriptionClientOptions;\n\n      if (maybeRun) {\n        run = maybeRun;\n        options = optionsOrRun as GadgetSubscriptionClientOptions;\n      } else {\n        run = optionsOrRun as TransactionRun<T>;\n        options = {};\n      }\n\n      if (this.currentTransaction) {\n        return await run(this.currentTransaction);\n      }\n\n      let subscriptionClient: SubscriptionClient | null = null;\n      let transaction;\n      try {\n        // The server will error if it receives any operations before the auth dance has been completed, so we block on that happening before sending our first operation. It's important that this happens synchronously after instantiating the client so we don't miss any messages\n        subscriptionClient = await this.waitForOpenedConnection({\n          isFatalConnectionProblem(errorOrCloseEvent) {\n            // any interruption of the transaction is fatal to the transaction\n            console.warn(\"Transport error encountered during transaction processing\", errorOrCloseEvent);\n            return true;\n          },\n          connectionAckWaitTimeout: DEFAULT_CONN_ACK_TIMEOUT,\n          ...options,\n          lazy: false,\n          // super ultra critical option that ensures graphql-ws doesn't automatically close the websocket connection when there are no outstanding operations. this is key so we can start a transaction then make mutations within it\n          lazyCloseTimeout: 100000,\n          retryAttempts: 0,\n        });\n\n        const client = new Client({\n          url: \"/-\", // not used because there's no fetch exchange, set for clarity\n          exchanges: [\n            subscriptionExchange({\n              forwardSubscription(operation) {\n                return {\n                  subscribe: (sink) => {\n                    const dispose = subscriptionClient!.subscribe(operation, sink as Sink<ExecutionResult>);\n                    return {\n                      unsubscribe: dispose,\n                    };\n                  },\n                };\n              },\n              enableAllOperations: true,\n            }),\n          ],\n        });\n\n        transaction = new GadgetTransaction(client, subscriptionClient);\n        this.currentTransaction = transaction;\n        await transaction.start();\n        const result = await run(transaction);\n        await transaction.commit();\n        return result;\n      } catch (error) {\n        try {\n          if (transaction?.open) await transaction.rollback();\n        } catch (rollbackError) {\n          if (!(rollbackError instanceof TransactionRolledBack)) {\n            console.warn(\"Encountered another error while rolling back a Gadget transaction that errored. The other error:\", rollbackError);\n          }\n        }\n        if (isCloseEvent(error)) {\n          throw new Error(`GraphQL websocket closed unexpectedly by the server with error code ${error.code} and reason \"${error.reason}\"`);\n        } else {\n          throw error;\n        }\n      } finally {\n        await subscriptionClient?.dispose();\n        this.currentTransaction = null;\n      }\n    }\n  );\n\n  close() {\n    void this.baseSubscriptionClient.dispose();\n    if (this.currentTransaction) {\n      this.currentTransaction.close();\n    }\n  }\n\n  /** `fetch` wrapper that applies Gadget's session token logic on the request and retrieves it from the reply */\n  fetch = traceFunction(\"api-client.fetch\", async (input: RequestInfo, init: RequestInit = {}) => {\n    init.headers = { ...this.requestHeaders(), ...init.headers };\n\n    const response = await this.fetchImplementation(input, init);\n    if (this.authenticationMode == AuthenticationMode.BrowserSession) {\n      const headerValue = response.headers.get(\"x-set-authorization\");\n      const sessionToken = headerValue?.startsWith(\"Session \") ? headerValue.replace(\"Session \", \"\") : null;\n      if (sessionToken) {\n        this.sessionTokenStore!.setItem(sessionStorageKey, sessionToken);\n      }\n    }\n    return response;\n  });\n\n  private resetClients() {\n    if (this.currentTransaction) {\n      throw new Error(\"Can't reset clients while a transaction is open\");\n    }\n\n    void this.baseSubscriptionClient?.dispose();\n    if (this.baseClient) this.baseClient = this.newBaseClient();\n  }\n\n  private newBaseClient() {\n    const exchanges = [dedupExchange];\n\n    // apply urql's default caching behaviour when client side (but skip it server side)\n    if (typeof window != \"undefined\") {\n      exchanges.push(cacheExchange);\n    }\n\n    exchanges.push(\n      multipartFetchExchange,\n      subscriptionExchange({\n        forwardSubscription: (operation) => {\n          return {\n            subscribe: (sink) => {\n              const dispose = this.baseSubscriptionClient.subscribe(operation, sink as Sink<ExecutionResult>);\n              return {\n                unsubscribe: dispose,\n              };\n            },\n          };\n        },\n      })\n    );\n\n    return new Client({ url: this.endpoint, fetch: this.fetch, exchanges });\n  }\n\n  private newSubscriptionClient(overrides: GadgetSubscriptionClientOptions) {\n    // In the browser, we can't set arbitrary headers on the websocket request, so we don't use the same auth mechanism that we use for normal HTTP requests. Instead we use graphql-ws' connectionParams to send the auth information in the connection setup message to the server.\n    const auth: any = { type: this.authenticationMode };\n    if (this.authenticationMode == AuthenticationMode.APIKey) {\n      auth.key = this.options.authenticationMode!.apiKey!;\n    } else if (this.authenticationMode == AuthenticationMode.InternalAuthToken) {\n      auth.token = this.options.authenticationMode!.internalAuthToken!;\n    } else if (this.authenticationMode == AuthenticationMode.BrowserSession) {\n      auth.sessionToken = this.sessionTokenStore!.getItem(sessionStorageKey);\n    }\n\n    let url = this.websocketsEndpoint;\n    if (overrides?.urlParams) {\n      const params = new URLSearchParams();\n      for (const [key, value] of Object.entries(overrides.urlParams)) {\n        if (value) {\n          params.set(key, value);\n        }\n      }\n      url += \"?\" + params.toString();\n    }\n\n    return createSubscriptionClient({\n      url,\n      webSocketImpl: this.websocketImplementation,\n      connectionParams: { auth, environment: this.environment },\n      onNonLazyError: () => {\n        // we catch this outside in the runner function\n      },\n      on: {\n        connected: (socket, payload) => {\n          // If we're using session token authorization, we don't use request headers to exchange the session token, we use graphql-ws' ConnectionAck payload to persist the token. When the subscription client first starts, the server will send us session token identifying this client, and we persist it to the session token store\n          if (this.authenticationMode == AuthenticationMode.BrowserSession && payload?.sessionToken) {\n            this.sessionTokenStore!.setItem(sessionStorageKey, payload.sessionToken as string);\n          }\n          this.subscriptionClientOptions?.on?.connected?.(socket, payload);\n          overrides?.on?.connected?.(socket, payload);\n        },\n      },\n      ...this.subscriptionClientOptions,\n      ...overrides,\n    });\n  }\n\n  private requestHeaders() {\n    const headers: Record<string, string> = {};\n\n    if (this.authenticationMode == AuthenticationMode.InternalAuthToken) {\n      headers.authorization = \"Basic \" + base64(\"gadget-internal\" + \":\" + this.options.authenticationMode!.internalAuthToken!);\n    } else if (this.authenticationMode == AuthenticationMode.APIKey) {\n      headers.authorization = `Bearer ${this.options.authenticationMode?.apiKey}`;\n    } else if (this.authenticationMode == AuthenticationMode.BrowserSession) {\n      const val = this.sessionTokenStore!.getItem(sessionStorageKey);\n      if (val) {\n        headers.authorization = `Session ${val}`;\n      }\n    }\n\n    headers[\"x-gadget-environment\"] = this.environment;\n\n    return headers;\n  }\n\n  private async waitForOpenedConnection(options: GadgetSubscriptionClientOptions): Promise<SubscriptionClient> {\n    let subscriptionClient = this.newSubscriptionClient(options);\n    let unsubscribes: Function[] = []; // eslint-disable-line @typescript-eslint/ban-types\n\n    let attempts = options.connectionAttempts || DEFAULT_CONN_ATTEMPTS;\n    const globalTimeout = options.connectionGlobalTimeoutMs || DEFAULT_CONN_GLOBAL_TIMEOUT;\n\n    const clearListeners = () => {\n      unsubscribes.forEach((fn) => fn());\n      unsubscribes = [];\n    };\n\n    return await new Promise<SubscriptionClient>((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        void subscriptionClient.dispose();\n        wrappedReject(new Error(\"Timeout opening websocket connection to Gadget API\"));\n      }, globalTimeout);\n\n      const retryOnClose = (event: unknown) => {\n        let message = \"unknown close event\";\n\n        if (isCloseEvent(event)) {\n          if (event.code == CloseCode.ConnectionAcknowledgementTimeout && attempts > 0) {\n            attempts -= 1;\n            void subscriptionClient.dispose();\n            subscriptionClient = this.newSubscriptionClient(options);\n            resetListeners();\n            return;\n          }\n          message = `CloseEvent: ${event.reason}`;\n        }\n\n        clearTimeout(timeout);\n        reject(new Error(message));\n      };\n\n      const wrappedReject = (err: any) => {\n        clearTimeout(timeout);\n        reject(err);\n      };\n\n      const wrappedResolve = () => {\n        clearTimeout(timeout);\n        resolve(subscriptionClient);\n      };\n\n      const resetListeners = () => {\n        clearListeners();\n        unsubscribes.push(subscriptionClient.on(\"connected\", wrappedResolve));\n        unsubscribes.push(subscriptionClient.on(\"closed\", retryOnClose));\n        unsubscribes.push(subscriptionClient.on(\"error\", wrappedReject));\n      };\n\n      resetListeners();\n    }).finally(clearListeners);\n  }\n}\n"]}