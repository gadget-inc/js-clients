{"version":3,"file":"GadgetRecordList.js","sourceRoot":"","sources":["../../src/GadgetRecordList.ts"],"names":[],"mappings":";;;AAMA,uCAAoE;AAOpE,gGAAgG;AAChG,MAAa,gBAA4C,SAAQ,KAA0B;IAA3F;;QACE;;;;;WAAsD;QACtD;;;;;WAA8B;IA8DhC,CAAC;IA5DC,iFAAiF;IACjF,MAAM,CAAC,IAAI,CACT,YAAoD,EACpD,KAA4B,EAC5B,UAA4B;QAE5B,MAAM,IAAI,GAAG,IAAI,gBAAgB,EAAS,CAAC;QAC3C,IAAI,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC;QACpB,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACpB,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC;QACzB,OAAO,KAAK,CAAC;IACf,CAAC;IAED,YAAY;QACV,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;YACZ,MAAM,IAAI,8BAAoB,CAAC,mBAAmB,EAAE,sBAAsB,CAAC,CAAC;SAC7E;QACD,OAAO,IAAI,CAAC,CAAC,CAAC,CAAC;IACjB,CAAC;IAED,MAAM;QACJ,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;IAC/C,CAAC;IAED,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,WAAW,CAAC;IAC9C,CAAC;IAED,IAAI,eAAe;QACjB,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,eAAe,CAAC;IAClD,CAAC;IAED,KAAK,CAAC,QAAQ;;QACZ,IAAI,CAAC,IAAI,CAAC,WAAW;YACnB,MAAM,IAAI,2BAAiB,CAAC,kGAAkG,CAAC,CAAC;QAClI,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC;YAC1C,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO;YAC1B,KAAK,EAAE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,SAAS;YACzC,KAAK,EAAE,CAAA,MAAA,IAAI,CAAC,UAAU,CAAC,OAAO,0CAAE,KAAK,MAAI,MAAA,IAAI,CAAC,UAAU,CAAC,OAAO,0CAAE,IAAI,CAAA;SACvE,CAAqC,CAAC;QACvC,OAAO,MAAM,QAAQ,CAAC;IACxB,CAAC;IAED,KAAK,CAAC,YAAY;;QAChB,IAAI,CAAC,IAAI,CAAC,eAAe;YACvB,MAAM,IAAI,2BAAiB,CACzB,0GAA0G,CAC3G,CAAC;QACJ,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC;YAC1C,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO;YAC1B,MAAM,EAAE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,WAAW;YAC5C,IAAI,EAAE,CAAA,MAAA,IAAI,CAAC,UAAU,CAAC,OAAO,0CAAE,IAAI,MAAI,MAAA,IAAI,CAAC,UAAU,CAAC,OAAO,0CAAE,KAAK,CAAA;SACtE,CAAqC,CAAC;QACvC,OAAO,MAAM,QAAQ,CAAC;IACxB,CAAC;CACF;AAhED,4CAgEC","sourcesContent":["/* eslint-disable no-throw-literal */\n/* eslint-disable @typescript-eslint/require-await */\nimport { GadgetRecord, RecordShape } from \"./GadgetRecord\";\nimport type { InternalModelManager } from \"./InternalModelManager\";\nimport type { AnyModelManager } from \"./ModelManager\";\nimport type { PaginationOptions } from \"./operationBuilders\";\nimport { GadgetClientError, GadgetOperationError } from \"./support\";\n\ntype PaginationConfig = {\n  pageInfo: { hasNextPage: boolean; hasPreviousPage: boolean; startCursor: string; endCursor: string };\n  options?: PaginationOptions;\n};\n\n/** Represents a list of objects returned from the API. Facilitates iterating and paginating. */\nexport class GadgetRecordList<Shape extends RecordShape> extends Array<GadgetRecord<Shape>> {\n  modelManager!: AnyModelManager | InternalModelManager;\n  pagination!: PaginationConfig;\n\n  /** Internal method used to create a list. Should not be used by applications. */\n  static boot<Shape extends RecordShape>(\n    modelManager: AnyModelManager | InternalModelManager,\n    nodes: GadgetRecord<Shape>[],\n    pagination: PaginationConfig\n  ) {\n    const list = new GadgetRecordList<Shape>();\n    list.push(...nodes);\n    list.modelManager = modelManager;\n    list.pagination = pagination;\n    Object.freeze(list);\n    return list;\n  }\n\n  static get [Symbol.species]() {\n    return Array;\n  }\n\n  firstOrThrow() {\n    if (!this[0]) {\n      throw new GadgetOperationError(\"No records found.\", \"GGT_RECORD_NOT_FOUND\");\n    }\n    return this[0];\n  }\n\n  toJSON() {\n    return this.map((record) => record.toJSON());\n  }\n\n  get hasNextPage() {\n    return this.pagination.pageInfo.hasNextPage;\n  }\n\n  get hasPreviousPage() {\n    return this.pagination.pageInfo.hasPreviousPage;\n  }\n\n  async nextPage() {\n    if (!this.hasNextPage)\n      throw new GadgetClientError(\"Cannot request next page because there isn't one, should check 'hasNextPage' to see if it exists\");\n    const nextPage = this.modelManager.findMany({\n      ...this.pagination.options,\n      after: this.pagination.pageInfo.endCursor,\n      first: this.pagination.options?.first || this.pagination.options?.last,\n    }) as Promise<GadgetRecordList<Shape>>;\n    return await nextPage;\n  }\n\n  async previousPage() {\n    if (!this.hasPreviousPage)\n      throw new GadgetClientError(\n        \"Cannot request previous page because there isn't one, should check 'hasPreviousPage' to see if it exists\"\n      );\n    const prevPage = this.modelManager.findMany({\n      ...this.pagination.options,\n      before: this.pagination.pageInfo.startCursor,\n      last: this.pagination.options?.last || this.pagination.options?.first,\n    }) as Promise<GadgetRecordList<Shape>>;\n    return await prevPage;\n  }\n}\n"]}