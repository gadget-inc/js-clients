{"version":3,"file":"useFetch.js","sourceRoot":"","sources":["../../../src/hooks/useFetch.ts"],"names":[],"mappings":"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","sourcesContent":["import { RuntimeAdapter } from \"../adaptors/types.js\";\nimport { CoreHooks } from \"../createHooks.js\";\nimport { ErrorWrapper } from \"./utils.js\";\n\nexport interface FetchHookOptions extends RequestInit {\n  stream?: boolean | string;\n  json?: boolean;\n  sendImmediately?: boolean;\n  onStreamComplete?: (value: string) => void;\n}\n\nexport type FetchHookResult<T, U = T> = [FetchHookState<T>, (opts?: Partial<FetchHookOptions>) => Promise<U>];\n\ntype FetchAction<T> =\n  | { type: \"fetching\" }\n  | { type: \"streaming\" }\n  | { type: \"fetched\"; payload: T }\n  | { type: \"streamed\" }\n  | { type: \"update\"; payload: T }\n  | { type: \"error\"; payload: ErrorWrapper };\n\nconst reducer = <T>(state: FetchHookState<T>, action: FetchAction<T>): FetchHookState<T> => {\n  switch (action.type) {\n    case \"fetching\":\n      return { ...state, fetching: true, streaming: false, error: undefined };\n    case \"streaming\":\n      return { ...state, streaming: true };\n    case \"streamed\":\n      return { ...state, streaming: false };\n    case \"fetched\":\n      return { ...state, fetching: false, data: action.payload, error: undefined };\n    case \"update\":\n      return { ...state, data: action.payload };\n    case \"error\":\n      return { ...state, fetching: false, error: action.payload };\n    default:\n      return state;\n  }\n};\n\nexport interface FetchHookState<T> {\n  data?: T;\n  response?: Response;\n  error?: ErrorWrapper;\n  fetching: boolean;\n  streaming: boolean;\n  options: FetchHookOptions;\n}\n\nconst startRequestByDefault = (options?: FetchHookOptions) => {\n  if (typeof options?.sendImmediately != \"undefined\") {\n    return options.sendImmediately;\n  } else {\n    return !options?.method || options.method === \"GET\";\n  }\n};\n\nconst dispatchError = (\n  mounted: { current: boolean },\n  dispatch: (action: FetchAction<any>) => void,\n  abortController: AbortController,\n  error: any,\n  response?: Response\n) => {\n  if (!mounted.current || abortController.signal.aborted) return null;\n\n  const wrapped = ErrorWrapper.forClientSideError(error, response);\n  dispatch({ type: \"error\", payload: wrapped });\n\n  return wrapped;\n};\n\nexport const createUseFetch = (adapter: RuntimeAdapter, coreHooks: CoreHooks) => {\n  function useFetch(path: string, options: { stream: string } & FetchHookOptions): FetchHookResult<string, ReadableStream<string>>;\n  function useFetch(path: string, options: { stream: true } & FetchHookOptions): FetchHookResult<ReadableStream<Uint8Array>>;\n  function useFetch<T extends Record<string, any>>(url: string, options: { json: true } & FetchHookOptions): FetchHookResult<T>;\n  function useFetch(path: string, options?: FetchHookOptions): FetchHookResult<string>;\n  function useFetch<T = string>(path: string, options?: FetchHookOptions): FetchHookResult<T> {\n    // Used to prevent state update if the component is unmounted\n    const mounted = adapter.framework.useRef<boolean>(true);\n    const { onStreamComplete, ...optionsToMemoize } = options ?? {};\n    const memoizedOptions = coreHooks.useStructuralMemo<FetchHookOptions>(optionsToMemoize);\n    const connection = coreHooks.useConnection();\n    const startRequestOnMount = startRequestByDefault(memoizedOptions);\n    const controller = adapter.framework.useRef<AbortController | null>(null);\n\n    const [state, dispatch] = adapter.framework.useReducer<FetchHookState<T>, FetchHookOptions, [FetchAction<T>]>(\n      reducer,\n      memoizedOptions,\n      (memoizedOptions) => {\n        return { fetching: startRequestOnMount, streaming: false, options: memoizedOptions };\n      }\n    );\n\n    const send = adapter.framework.useCallback(\n      async (sendOptions?: Partial<FetchHookOptions>): Promise<T> => {\n        if (controller.current && !controller.current.signal.aborted) {\n          controller.current.abort(\"useFetch is starting a new request, aborting the previous one\");\n        }\n\n        const abortContoller = new AbortController();\n        controller.current = abortContoller;\n\n        dispatch({ type: \"fetching\" });\n\n        let data: any;\n        let response: Response | undefined = undefined;\n\n        const mergedOptions = { ...memoizedOptions, onStreamComplete, ...sendOptions };\n\n        // add implicit headers from options, being careful not to mutate any inputs\n        if (mergedOptions.json) {\n          mergedOptions.headers = { ...mergedOptions.headers };\n          (mergedOptions.headers as any)[\"accept\"] ??= \"application/json\";\n        }\n\n        try {\n          const { json: _json, stream: _stream, onStreamComplete: _onStreamComplete, ...fetchOptions } = mergedOptions;\n          // make the fetch call using GadgetConnection to pass along auth and other headers\n          response = await connection.fetch(path, { signal: abortContoller.signal, ...fetchOptions });\n          if (!response.ok) {\n            throw new Error(response.statusText);\n          }\n\n          let dispatchData = true;\n\n          if (mergedOptions.json) {\n            data = await response.json();\n          } else if (typeof mergedOptions.stream === \"string\") {\n            dispatchData = false;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const decodedStream = response.body!.pipeThrough(\n              new TextDecoderStream(mergedOptions.stream === \"string\" ? \"utf8\" : mergedOptions.stream)\n            );\n\n            const [responseStream, updateStream] = decodedStream.tee();\n\n            data = responseStream;\n            const decodedStreamReader = updateStream.getReader();\n\n            decodedStreamReader.closed.catch((error) => {\n              dispatchError(mounted, dispatch, abortContoller, error, response);\n            });\n\n            dispatch({ type: \"fetched\", payload: \"\" as any });\n\n            (async () => {\n              let responseText = \"\";\n              let done = false;\n\n              dispatch({ type: \"streaming\" });\n\n              while (!done) {\n                const { value, done: _done } = await decodedStreamReader.read();\n                done = _done;\n\n                if (value) {\n                  responseText += value;\n\n                  if (!abortContoller.signal.aborted) {\n                    dispatch({ type: \"update\", payload: responseText as any });\n                  }\n                }\n              }\n\n              mergedOptions.onStreamComplete?.(responseText);\n            })()\n              .catch((error) => {\n                dispatchError(mounted, dispatch, abortContoller, error, response);\n              })\n              .finally(() => {\n                dispatch({ type: \"streamed\" });\n              });\n          } else if (mergedOptions.stream) {\n            data = response.body;\n          } else {\n            data = await response.text();\n          }\n\n          if (!mounted.current || !dispatchData) return data;\n\n          dispatch({ type: \"fetched\", payload: data });\n        } catch (error: any) {\n          const wrapped = dispatchError(mounted, dispatch, abortContoller, error, response);\n          if (!wrapped) return null as any;\n          throw wrapped;\n        }\n        return data;\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [connection, memoizedOptions, path]\n    );\n\n    // track if we're mounted or not\n    adapter.framework.useEffect(() => {\n      mounted.current = true;\n\n      return () => {\n        mounted.current = false;\n      };\n    }, []);\n\n    // execute the initial request on mount if needed\n    adapter.framework.useEffect(() => {\n      if (startRequestOnMount) {\n        void send().catch(() => {\n          // error will be reported via the return value of the hook\n        });\n      }\n\n      // abort if the component is unmounted, or if one of the key elements of the request changes such that we don't want an outstanding request's result anymore\n      return () => {\n        controller.current?.abort();\n      };\n    }, [path, startRequestOnMount, send]);\n\n    return [state, send];\n  }\n\n  return {\n    /**\n     * Hook to make an HTTP request to a Gadget backend HTTP route. Preserves client side session information and ensures it's passed along to the backend.\n     *\n     * Returns a tuple with the current state of the request and a function to send or re-send the request. The state is an object with the following fields:\n     * - `data`: the response data, if the request was successful\n     * - `fetching`: a boolean describing if the fetch request is currently in progress\n     * - `streaming`: a boolean describing if the fetch request is currently streaming. This is only set when the option `{ stream: \"string\" }` is passed\n     * - `error`: an error object if the request failed in any way\n     *\n     * The second return value is a function for executing the fetch request. It returns a promise for the response body.\n     *\n     * By default, `GET` requests are sent as soon as the hook executes. Any other request methods are not sent automatically, and must be triggered by calling the `execute` function returned in the second argument.\n     *\n     * Pass the `{ json: true }` option to expect a JSON response from the server, and to automatically parse the response as JSON. Otherwise, the response will be returned as a `string` object.\n     *\n     * Pass the `{ stream: true }` to get a `ReadableStream` object as a response from the server, allowing you to work with the response as it arrives.\n     *\n     * Pass the `{ stream: \"string\" }` to decode the `ReadableStream` as a string and update data as it arrives. If the stream is in an encoding other than utf8 use i.e. `{ stream: \"utf-16\" }`.\n     *\n     * When `{ stream: \"string\" }` is used, the `streaming` field in the state will be set to `true` while the stream is active, and `false` when the stream is complete. You can use this to show a loading indicator while the stream is active.\n     * You can also pass an `onStreamComplete` callback that will be called with the value of the streamed string once it has completed.\n     *\n     * If you want to read model data, see the `useFindMany` function and similar. If you want to invoke a backend Action, use the `useAction` hook instead.\n     *\n     * @param path the backend path to fetch\n     * @param options the `fetch` options for the request\n     *\n     * @example\n     * ```\n     * export function UserByEmail(props: { email: string }) {\n     *   const [{data, fetching, error}, refresh] = useFetch(\"/users/get\", {\n     *     method: \"GET\",\n     *     body: JSON.stringify({ email: props.email }})\n     *     headers: {\n     *       \"content-type\": \"application/json\",\n     *     }\n     *     json: true,\n     *   });\n     *\n     *   if (result.error) return <>Error: {result.error.toString()}</>;\n     *   if (result.fetching && !result.data) return <>Fetching...</>;\n     *   if (!result.data) return <>No user found with id={props.id}</>;\n     *\n     *   return <div>{result.data.name}</div>;\n     * }\n     */\n    useFetch,\n  };\n};\n"]}