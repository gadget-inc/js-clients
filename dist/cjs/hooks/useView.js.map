{"version":3,"file":"useView.js","sourceRoot":"","sources":["../../../src/hooks/useView.ts"],"names":[],"mappings":";;;AAGA,8CAAuD;AAEvD,yCAA8F;AAEvF,MAAM,aAAa,GAAG,CAAC,OAAuB,EAAE,SAAoB,EAAE,EAAE;IAmF7E,SAAS,OAAO,CACd,IAAgB,EAChB,kBAAoE,EACpE,YAAiD;;QAEjD,IAAI,SAAiC,CAAC;QACtC,IAAI,OAAuD,CAAC;QAE5D,IAAI,OAAO,IAAI,IAAI,QAAQ,IAAI,WAAW,IAAI,IAAI,EAAE,CAAC;YACnD,SAAS,GAAG,kBAAgC,CAAC;YAC7C,OAAO,GAAG,YAAY,CAAC;QACzB,CAAC;aAAM,IAAI,kBAAkB,EAAE,CAAC;YAC9B,OAAO,GAAG,kBAAwD,CAAC;QACrE,CAAC;QAED,MAAM,iBAAiB,GAAG,SAAS,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;QACjE,MAAM,eAAe,GAAG,SAAS,CAAC,iBAAiB,CAAC;YAClD,GAAG,OAAO;YACV,OAAO,EAAE;gBACP,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,OAAO;gBACnB,yJAAyJ;gBACzJ,mBAAmB,EAAE;oBACnB,GAAG,CAAC,MAAA,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,OAAO,0CAAE,mBAAmB,mCAAI,EAAE,CAAC;oBAChD,GAAG,CAAC,OAAO,IAAI,IAAI,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAA,IAAI,CAAC,mBAAmB,mCAAI,EAAE,CAAC;iBACnE;aACF;SACF,CAAC,CAAC;QAEH,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC,GAAiD,EAAE;YACpG,IAAI,OAAO,IAAI,IAAI,QAAQ,EAAE,CAAC;gBAC5B,OAAO,CAAC,EAAE,KAAK,EAAE,eAAe,EAAE,SAAS,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,SAAS,EAAE,iBAAiB,EAAE,EAAE,EAAE,CAAC,WAAW,CAAC,CAAC,CAAC;YAC/G,CAAC;iBAAM,CAAC;gBACN,MAAM,gBAAgB,GAAqB,EAAE,CAAC;gBAC9C,IAAI,WAAW,IAAI,IAAI,IAAI,iBAAiB,EAAE,CAAC;oBAC7C,KAAK,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;wBAC9D,MAAM,KAAK,GAAG,iBAAiB,CAAC,IAAsC,CAAY,CAAC;wBACnF,IAAI,OAAO,KAAK,IAAI,WAAW,IAAI,KAAK,KAAK,IAAI,EAAE,CAAC;4BAClD,gBAAgB,CAAC,IAAI,CAAC,GAAG;gCACvB,KAAK;gCACL,GAAG,QAAQ;6BACZ,CAAC;wBACJ,CAAC;oBACH,CAAC;gBACH,CAAC;gBAED,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE,IAAA,8BAAiB,EAAC,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;YAC/F,CAAC;QACH,CAAC,EAAE,CAAC,IAAI,EAAE,iBAAiB,CAAC,CAAC,CAAC;QAE9B,MAAM,CAAC,SAAS,EAAE,OAAO,CAAC,GAAG,SAAS,CAAC,cAAc,CAAC,IAAA,uBAAY,EAAC,IAAI,EAAE,eAAe,CAAC,CAAC,CAAC;QAE3F,MAAM,MAAM,GAAG,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,EAAE;YAC5C,MAAM,IAAI,GAAG,IAAA,gBAAG,EAAC,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;YAC3C,MAAM,KAAK,GAAG,uBAAY,CAAC,iBAAiB,CAAC,SAAS,EAAE,QAAQ,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,KAAK,CAAC,CAAC;YAElF,OAAO,EAAE,GAAG,SAAS,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;QACvC,CAAC,EAAE,CAAC,QAAQ,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,KAAK,EAAE,SAAS,CAAC,CAAC,CAAC;QAE1C,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAC3B,CAAC;IAED,OAAO;QACL,OAAO;KACR,CAAC;AACJ,CAAC,CAAC;AAnJW,QAAA,aAAa,iBAmJxB;AAEF,MAAM,eAAe,GAAG;;EAEtB,CAAC","sourcesContent":["import { GQLBuilderResult, ViewFunction, ViewFunctionWithVariables, ViewFunctionWithoutVariables } from \"../GadgetFunctions.js\";\nimport { RuntimeAdapter } from \"../adaptors/types.js\";\nimport { CoreHooks } from \"../createHooks.js\";\nimport { get, namespaceDataPath } from \"../support.js\";\nimport { VariablesOptions, ViewResult } from \"../types.js\";\nimport { ErrorWrapper, ReadHookResult, ReadOperationOptions, useQueryArgs } from \"./utils.js\";\n\nexport const createUseView = (adapter: RuntimeAdapter, coreHooks: CoreHooks) => {\n  /**\n   * Hook to fetch the result of a computed view from the backend. Returns a standard hook result set with a tuple of the result object with `data`, `fetching`, and `error` keys, and a `refetch` function. `data` will be the shape of the computed view's result.\n   *\n   * @param view Gadget view function to run, like `api.leaderboard` or `api.todos.summary`\n   * @param options options for controlling client side execution\n   *\n   * @example\n   *\n   * ```\n   * export function Leaderboard() {\n   *   const [result, refresh] = useView(api.leaderboard);\n   *\n   *   if (result.error) return <>Error: {result.error.toString()}</>;\n   *   if (result.fetching && !result.data) return <>Fetching...</>;\n   *   if (!result.data) return <>No data found</>;\n   *\n   *   return <>{result.data.map((leaderboard) => <div>{leaderboard.name}: {leaderboard.score}</div>)}</>;\n   * }\n   * ```\n   */\n  function useView<F extends ViewFunctionWithoutVariables<any>>(\n    view: F,\n    options?: Omit<ReadOperationOptions, \"live\">\n  ): ReadHookResult<ViewResult<F>>;\n  /**\n   * Hook to fetch the result of a computed view with variables from the backend. Returns a standard hook result set with a tuple of the result object with `data`, `fetching`, and `error` keys, and a `refetch` function. `data` will be the shape of the computed view's result.\n   *\n   * @param manager Gadget view function to run\n   * @param variables variables to pass to the backend view\n   * @param options options for controlling client side execution\n   *\n   * @example\n   *\n   * ```\n   * export function Leaderboard() {\n   *   const [result, refresh] = useView(api.leaderboard, {\n   *     first: 10,\n   *   });\n   *\n   *   if (result.error) return <>Error: {result.error.toString()}</>;\n   *   if (result.fetching && !result.data) return <>Fetching...</>;\n   *   if (!result.data) return <>No data found</>;\n   *\n   *   return <>{result.data.map((leaderboard) => <div>{leaderboard.name}: {leaderboard.score}</div>)}</>;\n   * }\n   * ```\n   */\n  function useView<F extends ViewFunctionWithVariables<any, any>>(\n    view: F,\n    variables: F[\"variablesType\"],\n    options?: Omit<ReadOperationOptions, \"live\">\n  ): ReadHookResult<ViewResult<F>>;\n  /**\n   * Hook to fetch the result of an inline computed view with variables from the backend. Returns a standard hook result set with a tuple of the result object with `data`, `fetching`, and `error` keys, and a `refetch` function. `data` will be the shape of the computed view's result.\n   *\n   * Does not know the type of the result from the input string -- for type safety, use a named view defined in a .gelly file in the backend.\n   *\n   * @param view Gelly query string to run, like `{ count(todos) }`\n   * @param variables variables to pass to the backend view\n   * @param options options for controlling client side execution\n   *\n   * @example\n   *\n   * ```\n   * export function Leaderboard() {\n   *   const [result, refresh] = useView(\"{ count(todos) }\", {\n   *     first: 10,\n   *   });\n   *\n   *   if (result.error) return <>Error: {result.error.toString()}</>;\n   *   if (result.fetching && !result.data) return <>Fetching...</>;\n   *   if (!result.data) return <>No data found</>;\n   *\n   *   return <>{result.data.map((leaderboard) => <div>{leaderboard.name}: {leaderboard.score}</div>)}</>;\n   * }\n   * ```\n   */\n  function useView(\n    gellyQuery: string,\n    variables?: Record<string, unknown>,\n    options?: Omit<ReadOperationOptions, \"live\">\n  ): ReadHookResult<ViewResult<ViewFunction<unknown, unknown>>>;\n  function useView<VariablesT, F extends ViewFunction<VariablesT, any>>(\n    view: F | string,\n    variablesOrOptions?: VariablesT | Omit<ReadOperationOptions, \"live\">,\n    maybeOptions?: Omit<ReadOperationOptions, \"live\">\n  ): ReadHookResult<ViewResult<F>> {\n    let variables: VariablesT | undefined;\n    let options: Omit<ReadOperationOptions, \"live\"> | undefined;\n\n    if (typeof view == \"string\" || \"variables\" in view) {\n      variables = variablesOrOptions as VariablesT;\n      options = maybeOptions;\n    } else if (variablesOrOptions) {\n      options = variablesOrOptions as Omit<ReadOperationOptions, \"live\">;\n    }\n\n    const memoizedVariables = coreHooks.useStructuralMemo(variables);\n    const memoizedOptions = coreHooks.useStructuralMemo({\n      ...options,\n      context: {\n        ...options?.context,\n        // if the view exports the typenames it references, add them to the context so urql will refresh the view when mutations are made against these typenames\n        additionalTypenames: [\n          ...(options?.context?.additionalTypenames ?? []),\n          ...(typeof view == \"string\" ? [] : view.referencedTypenames ?? []),\n        ],\n      },\n    });\n\n    const [plan, dataPath] = adapter.framework.useMemo((): [plan: GQLBuilderResult, dataPath: string[]] => {\n      if (typeof view == \"string\") {\n        return [{ query: inlineViewQuery, variables: { query: view, variables: memoizedVariables } }, [\"gellyView\"]];\n      } else {\n        const variablesOptions: VariablesOptions = {};\n        if (\"variables\" in view && memoizedVariables) {\n          for (const [name, variable] of Object.entries(view.variables)) {\n            const value = memoizedVariables[name as keyof typeof memoizedVariables] as unknown;\n            if (typeof value != \"undefined\" && value !== null) {\n              variablesOptions[name] = {\n                value,\n                ...variable,\n              };\n            }\n          }\n        }\n\n        return [view.plan(variablesOptions), namespaceDataPath([view.gqlFieldName], view.namespace)];\n      }\n    }, [view, memoizedVariables]);\n\n    const [rawResult, refresh] = coreHooks.useGadgetQuery(useQueryArgs(plan, memoizedOptions));\n\n    const result = adapter.framework.useMemo(() => {\n      const data = get(rawResult.data, dataPath);\n      const error = ErrorWrapper.errorIfDataAbsent(rawResult, dataPath, options?.pause);\n\n      return { ...rawResult, data, error };\n    }, [dataPath, options?.pause, rawResult]);\n\n    return [result, refresh];\n  }\n\n  return {\n    useView,\n  };\n};\n\nconst inlineViewQuery = `query InlineView($query: String!, $variables: JSONObject) { \n  gellyView(query: $query, variables: $variables) \n}`;\n"]}