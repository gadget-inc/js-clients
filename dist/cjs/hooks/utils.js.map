{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/hooks/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { GraphQLError } from \"@0no-co/graphql.web\";\nimport type { AnyVariables, CombinedError, Operation, OperationContext, RequestPolicy } from \"@urql/core\";\nimport type { FieldSelection } from \"../FieldSelection.js\";\nimport { UseQueryState } from \"../adaptors/types.js\";\nimport { AnyActionFunction, AnyBulkActionFunction, BackgroundActionHandle, EnqueueBackgroundActionOptions } from \"../index.js\";\nimport { GadgetError, InvalidFieldError, InvalidRecordError, gadgetErrorFor, getNonNullableError } from \"../support.js\";\n\n/**\n * All the options controlling how this query will be managed by urql\n * */\nexport declare type ReadOperationOptions = {\n  /** Updates the {@link RequestPolicy} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `requestPolicy` modifies the {@link RequestPolicy} of the GraphQL query operation\n   * that `useQuery` executes, and indicates a caching strategy for cache exchanges.\n   *\n   * For example, when set to `'cache-and-network'`, {@link useQuery} will\n   * receive a cached result with `stale: true` and an API request will be\n   * sent in the background.\n   *\n   * @see {@link OperationContext.requestPolicy} for where this value is set.\n   */\n  requestPolicy?: RequestPolicy;\n  /** Updates the {@link OperationContext} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useQuery}, to update the {@link OperationContext}\n   * of a query operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * Hint: This should be wrapped in a `useMemo` hook, to make sure that your\n   * component doesn’t infinitely update.\n   *\n   * @example\n   * ```ts\n   * const [result, reexecute] = useQuery({\n   *   query,\n   *   context: useMemo(() => ({\n   *     additionalTypenames: ['Item'],\n   *   }), [])\n   * });\n   * ```\n   */\n  context?: Partial<OperationContext>;\n  /** Prevents {@link useQuery} from automatically executing GraphQL query operations.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useQuery} from executing\n   * automatically. The hook will stop receiving updates from the {@link Client}\n   * and won’t execute the query operation, until either it’s set to `false`\n   * or the {@link UseQueryExecute} function is called.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/react-preact/#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  pause?: boolean;\n  /**\n   * Marks this query as one that should suspend the react component rendering while executing, instead of returning `{fetching: true}` to the caller.\n   * Useful if you want to allow components higher in the tree to show spinners instead of having every component manage its own loading state.\n   */\n  suspense?: boolean;\n  /**\n   * Marks this query as a live query that will subscribe to changes from the backend and re-render when backend data changes with the newest data.\n   */\n  live?: boolean;\n};\n\nexport type OptionsType = {\n  [key: string]: any;\n  /** What fields to select from the resulting object */\n  select?: FieldSelection;\n  /** Subscribe to changes from the backend and return a new result as it changes */\n  live?: boolean;\n};\n\ninterface QueryPlan {\n  variables: any;\n  query: string;\n}\n\ninterface QueryOptions {\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n  requestPolicy?: RequestPolicy;\n  suspense?: boolean;\n}\n\n/**\n * Given a plan from a gadget query plan generator, create the query options object to pass to `urql`'s `useQuery` hook\n **/\nexport const useQueryArgs = <Plan extends QueryPlan, Options extends QueryOptions>(plan: Plan, options?: Options): any => ({\n  query: plan.query,\n  variables: plan.variables,\n  ...options,\n});\n\nexport const noProviderErrorMessage = `Could not find a client in the context of Provider. Please ensure you wrap the root component in a <Provider>`;\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (typeof error === \"string\") {\n    return new GraphQLError(error);\n  } else if (error?.message && !error.code) {\n    return new GraphQLError(error.message, error.nodes, error.source, error.positions, error.path, error, error.extensions || {});\n  } else {\n    return error;\n  }\n};\n\nconst generateErrorMessage = (networkErr?: Error, graphQlErrs?: GraphQLError[]) => {\n  let error = \"\";\n  if (networkErr !== undefined) {\n    error = `[Network] ${networkErr.message}`;\n  } else if (graphQlErrs !== undefined) {\n    graphQlErrs.forEach((err) => {\n      error += `[GraphQL] ${err.message}\\n`;\n    });\n  } else {\n    error = \"Unknown error\";\n  }\n\n  return error.trim();\n};\n\n/**\n * An error returned by any of the Gadget hooks.\n * Always has a message, but can be inspected to retrieve more detailed errors from either the network, the raw GraphQL layer, or Gadget specific errors like validation errors.\n * Not intended for creating outside of Gadget-owned code.\n **/\nexport class ErrorWrapper extends Error {\n  /** @private */\n  static forClientSideError(error: Error, response?: any) {\n    return new ErrorWrapper({\n      executionErrors: [error],\n      response,\n    });\n  }\n  /** @private */\n  static forErrorsResponse(errors: Record<string, any>[], response?: any) {\n    return new ErrorWrapper({\n      executionErrors: errors.map(gadgetErrorFor),\n      response,\n    });\n  }\n  /** @private */\n  static forMaybeCombinedError(error?: CombinedError | null) {\n    if (!error) return undefined;\n    return new ErrorWrapper({\n      networkError: error.networkError,\n      executionErrors: error.graphQLErrors,\n      response: error.response,\n    });\n  }\n  /** @private */\n  static errorIfDataAbsent(result: UseQueryState<any>, dataPath: string[], paused = false) {\n    const nonNullableError = getNonNullableError(result, dataPath);\n    let error = ErrorWrapper.forMaybeCombinedError(result.error);\n    if (!error && nonNullableError && !paused) {\n      error = ErrorWrapper.forClientSideError(nonNullableError);\n    }\n    return error;\n  }\n\n  /** Error message for this error. Derived from the other errors this wraps. */\n  public message: string;\n  /**\n   * A list of errors encountered by the backend when processing a request. Populated if the client successfully communicated with the backend, but the backend was unable to process the request and rejected it with an error.\n   * Includes GraphQL syntax errors, missing or invalid argument errors, data validation errors, or unexpected errors encountered when running backend logic.\n   **/\n  public executionErrors: (GraphQLError | GadgetError)[];\n  /**\n   * An error encountered when trying to communicate with the backend from the client. Includes things like connection timeouts, connection interrupts, or no internet connection errors\n   **/\n  public networkError?: Error;\n\n  /**\n   * A list of errors encountered by the backend when processing a request. Populated if the client successfully communicated with the backend, but the backend was unable to process the request and rejected it with an error.\n   * Includes GraphQL syntax errors, missing or invalid argument errors, data validation errors, or unexpected errors encountered when running backend logic.\n   *\n   * This property allows this object to match the interface of urql's `CombinedError` object.\n   *\n   * @deprecated use `executionErrors` instead for a list of the errors that the GraphQL backend API returned *and* client side errors from unexpected responses.\n   **/\n  public graphQLErrors: GraphQLError[];\n\n  /**\n   * The response from the server, if any was retrieved.\n   */\n  public response?: any;\n\n  constructor({\n    networkError,\n    executionErrors,\n    response,\n  }: {\n    networkError?: Error;\n    executionErrors?: Array<string | Partial<GraphQLError> | Error>;\n    validationErrors?: InvalidFieldError[];\n    response?: any;\n  }) {\n    const normalizedExecutionErrors = (executionErrors || []).map(rehydrateGraphQlError);\n    const message = generateErrorMessage(networkError, normalizedExecutionErrors);\n\n    super(message);\n\n    this.message = message;\n    this.executionErrors = normalizedExecutionErrors;\n    this.graphQLErrors = normalizedExecutionErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  /** Class name of this error -- always `ErrorWrapper` */\n  get name() {\n    return \"ErrorWrapper\";\n  }\n\n  toString() {\n    return this.message;\n  }\n\n  /**\n   * A list of errors the backend reported for specific fields being invalid for the records touched by an action. Is a shortcut for accessing the validation errors of a `GadgetInvalidRecordError` if that's what is in the `executionErrors`.\n   **/\n  public get validationErrors(): InvalidFieldError[] | null {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    const firstInvalidRecordError = this.executionErrors.find((err) => (err as any).code == \"GGT_INVALID_RECORD\") as\n      | InvalidRecordError\n      | undefined;\n\n    return firstInvalidRecordError?.validationErrors ?? null;\n  }\n}\n\n/**\n * The inner result object returned from a query result\n **/\nexport interface ReadHookState<Data = any, Variables extends AnyVariables = Record<string, any>> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: ErrorWrapper;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\n/**\n * The return value of a `useGet`, `useFindMany`, `useFindOne` etc hook.\n * Includes the data result object and a refetch function.\n **/\nexport declare type ReadHookResult<Data = any, Variables extends AnyVariables = AnyVariables> = [\n  ReadHookState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport type RequiredKeysOf<BaseType> = Exclude<\n  {\n    [Key in keyof BaseType]: BaseType extends Record<Key, BaseType[Key]> ? Key : never;\n  }[keyof BaseType],\n  undefined\n>;\n\n/**\n * The inner result object returned from a mutation result\n */\nexport interface ActionHookState<Data = any, Variables extends AnyVariables = Record<string, any>> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: ErrorWrapper;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\n/**\n * The return value of a `useAction`, `useGlobalAction`, `useBulkAction` etc hook.\n * Includes the data result object and a function for running the mutation.\n **/\nexport type ActionHookResult<Data = any, Variables extends AnyVariables = AnyVariables> = RequiredKeysOf<Variables> extends never\n  ? ActionHookResultWithOptionalCallbackVariables<Data, Variables>\n  : ActionHookResultWithRequiredCallbackVariables<Data, Variables>;\n\nexport type ActionHookResultWithOptionalCallbackVariables<Data = any, Variables extends AnyVariables = AnyVariables> = [\n  ActionHookState<Data, Variables>,\n  (variables?: Variables, context?: Partial<OperationContext>) => Promise<ActionHookState<Data, Variables>>\n];\n\nexport type ActionHookResultWithRequiredCallbackVariables<Data = any, Variables extends AnyVariables = AnyVariables> = [\n  ActionHookState<Data, Variables>,\n  (variables: Variables, context?: Partial<OperationContext>) => Promise<ActionHookState<Data, Variables>>\n];\n\n/**\n * The inner result object returned from a mutation result\n */\nexport type EnqueueHookState<SchemaT, Action extends AnyActionFunction> = Action extends AnyBulkActionFunction\n  ? {\n      fetching: boolean;\n      stale: boolean;\n      handles: BackgroundActionHandle<SchemaT, Action>[] | null;\n      error?: ErrorWrapper;\n      extensions?: Record<string, any>;\n      operation?: Operation<{ backgroundAction: { id: string } }, Action[\"variablesType\"]>;\n    }\n  : {\n      fetching: boolean;\n      stale: boolean;\n      handle: BackgroundActionHandle<SchemaT, Action> | null;\n      error?: ErrorWrapper;\n      extensions?: Record<string, any>;\n      operation?: Operation<{ backgroundAction: { id: string } }, Action[\"variablesType\"]>;\n    };\n\n/**\n * The return value of a `useEnqueue` hook.\n * Returns a two-element array:\n *  - the result object, with the keys like `handle`, `fetching`, and `error`\n *  - and a function for running the enqueue mutation.\n **/\nexport type EnqueueHookResult<SchemaT, Action extends AnyActionFunction> = RequiredKeysOf<\n  Exclude<Action[\"variablesType\"], null | undefined>\n> extends never\n  ? [\n      EnqueueHookState<SchemaT, Action>,\n      (\n        variables?: Action[\"variablesType\"],\n        backgroundOptions?: EnqueueBackgroundActionOptions<Action>,\n        context?: Partial<OperationContext>\n      ) => Promise<EnqueueHookState<SchemaT, Action>>\n    ]\n  : [\n      EnqueueHookState<SchemaT, Action>,\n      (\n        variables: Action[\"variablesType\"],\n        backgroundOptions?: EnqueueBackgroundActionOptions<Action>,\n        context?: Partial<OperationContext>\n      ) => Promise<EnqueueHookState<SchemaT, Action>>\n    ];\n\n/**\n * Wrapper to make a debounced function\n * NOTE: When using this within a component, make sure to wrap this in a `useCallback` so that the previous timeoutId is preserved between renders.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const debounce = (fn: Function, delayInMs = 300) => {\n  let timeoutId: ReturnType<typeof setTimeout>;\n\n  return (...args: any[]) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn.apply(this, args), delayInMs);\n  };\n};\n"]}