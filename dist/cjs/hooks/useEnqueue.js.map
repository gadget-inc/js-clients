{"version":3,"file":"useEnqueue.js","sourceRoot":"","sources":["../../../src/hooks/useEnqueue.ts"],"names":[],"mappings":"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","sourcesContent":["import { BackgroundActionHandle } from \"../BackgroundActionHandle.js\";\nimport { GadgetConnection } from \"../GadgetConnection.js\";\nimport { AnyActionFunction } from \"../GadgetFunctions.js\";\nimport { RuntimeAdapter, UseMutationState } from \"../adaptors/types.js\";\nimport { CoreHooks } from \"../createHooks.js\";\nimport { enqueueActionOperation, graphqlizeBackgroundOptions } from \"../operationBuilders.js\";\nimport { disambiguateActionVariables, disambiguateBulkActionVariables, get, namespaceDataPath } from \"../support.js\";\nimport { EnqueueBackgroundActionOptions } from \"../types.js\";\nimport { EnqueueHookResult, EnqueueHookState, ErrorWrapper } from \"./utils.js\";\n\nexport const createUseEnqueue = (adapter: RuntimeAdapter, coreHooks: CoreHooks) => {\n  const useEnqueue = <SchemaT, Action extends AnyActionFunction>(\n    action: Action,\n    baseBackgroundOptions?: EnqueueBackgroundActionOptions<Action>\n  ): EnqueueHookResult<SchemaT, Action> => {\n    const plan = adapter.framework.useMemo(\n      () => enqueueActionOperation(action.operationName, action.variables, action.namespace, null, action.isBulk),\n      [action]\n    );\n\n    const connection = coreHooks.useConnection();\n\n    const [rawState, runMutation] = coreHooks.useGadgetMutation(plan.query);\n\n    const state: EnqueueHookState<SchemaT, Action> = adapter.framework.useMemo(\n      () => processResult(connection, rawState, action),\n      [rawState, action]\n    );\n\n    return [\n      state,\n      adapter.framework.useCallback(\n        async (input: Action[\"variablesType\"], options?: EnqueueBackgroundActionOptions<Action>) => {\n          const variables = action.isBulk ? disambiguateBulkActionVariables(action, input) : disambiguateActionVariables(action, input);\n\n          const fullContext = { ...baseBackgroundOptions, ...options };\n          variables.backgroundOptions = graphqlizeBackgroundOptions(fullContext);\n\n          const rawState = await runMutation(variables, fullContext);\n\n          return processResult(connection, { fetching: false, ...rawState }, action);\n        },\n        [action, connection, runMutation]\n      ),\n    ];\n  };\n\n  return {\n    /**\n     * Hook to enqueue a Gadget action in the background. `useEnqueue` must be passed an action function from an instance of your generated API client library, like `useEnqueue(api.user.create)` or `useEnqueue(api.someGlobalAction)`. `useEnqueue` doesn't actually submit the background action when invoked, but instead returns a function for enqueuing the action in response to an event.\n     *\n     * @param action a model action or global action in your application's client, like `api.user.create` or `api.someGlobalAction`\n     * @param options action options, like selecting the fields in the result\n     *\n     * @example\n     * export function CreateUserButton(props: { name: string; email: string }) {\n     *   const [{error, fetching, handle}, enqueue] = useEnqueue(api.user.create));\n     *\n     *   const onClick = () => enqueue(\n     *     {\n     *       name: props.name,\n     *       email: props.email,\n     *     }, {\n     *       id: `send-email-action-${props.email}`\n     *     }\n     *   );\n     *\n     *   return (\n     *     <>\n     *       {error && <>Failed to enqueue user create: {error.toString()}</>}\n     *       {fetching && <>Enqueuing action...</>}\n     *       {data && <>Enqueued action with background action id={handle.id}</>}\n     *       <button onClick={onClick}>Create user</button>\n     *     </>\n     *   );\n     * }\n     */\n    useEnqueue,\n  };\n};\n\n/** Processes urql's result object into the fancier Gadget result object */\nconst processResult = <SchemaT, Action extends AnyActionFunction>(\n  connection: GadgetConnection,\n  rawResult: UseMutationState<any, any>,\n  action: Action\n): EnqueueHookState<SchemaT, Action> => {\n  const { data, ...result } = rawResult;\n  let error = ErrorWrapper.forMaybeCombinedError(result.error);\n  let handle: BackgroundActionHandle<SchemaT, Action> | null = null;\n  let handles: BackgroundActionHandle<SchemaT, Action>[] | null = null;\n  const isBulk = action.isBulk;\n\n  if (data) {\n    const dataPath = [\"background\", ...namespaceDataPath([action.operationName], action.namespace)];\n\n    const mutationData = get(data, dataPath);\n    if (mutationData) {\n      const errors = mutationData[\"errors\"];\n      if (errors && errors[0]) {\n        error = ErrorWrapper.forErrorsResponse(errors, error?.response);\n      } else {\n        if (isBulk) {\n          handles = mutationData.backgroundActions.map(\n            (result: { id: string }) => new BackgroundActionHandle<SchemaT, Action>(connection, action, result.id)\n          );\n        } else {\n          handle = new BackgroundActionHandle<SchemaT, Action>(connection, action, mutationData.backgroundAction.id);\n        }\n      }\n    }\n  }\n\n  if (isBulk) {\n    return { ...result, error, handles } as EnqueueHookState<SchemaT, Action>;\n  } else {\n    return { ...result, error, handle } as EnqueueHookState<SchemaT, Action>;\n  }\n};\n"]}