{"version":3,"file":"useTable.js","sourceRoot":"","sources":["../../src/useTable.tsx"],"names":[],"mappings":"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","sourcesContent":["import type { FieldSelection } from \"@gadgetinc/api-client-core\";\nimport {\n  type DefaultSelection,\n  type FindManyFunction,\n  type GadgetRecord,\n  type LimitToKnownKeys,\n  type Select,\n} from \"@gadgetinc/api-client-core\";\nimport type { OperationContext } from \"@urql/core\";\nimport { useMemo } from \"react\";\nimport { GadgetFieldType } from \"./internal/gql/graphql.js\";\nimport type { ModelMetadata } from \"./metadata.js\";\nimport { filterAutoTableFieldList, useModelMetadata } from \"./metadata.js\";\nimport type { SearchResult } from \"./useDebouncedSearch.js\";\nimport type { PaginationResult } from \"./useList.js\";\nimport { useList } from \"./useList.js\";\nimport type { RelatedFieldColumn } from \"./utils.js\";\nimport { isRelatedFieldColumn, type ColumnValueType, type ErrorWrapper, type OptionsType, type ReadOperationOptions } from \"./utils.js\";\n\nexport interface TableColumn {\n  name: string;\n  apiIdentifier: string;\n  fieldType: GadgetFieldType;\n  getValue: (record: GadgetRecord<any>) => ColumnValueType;\n  sortable: boolean;\n  relatedField?: TableColumn;\n}\n\nexport interface TableOptions {\n  pageSize?: number;\n  initialCursor?: string;\n  initialDirection?: \"forward\" | \"backward\";\n  columns?: (string | RelatedFieldColumn)[];\n}\n\nexport type TableData<Data> =\n  | {\n      columns: TableColumn[];\n      rows: Record<string, ColumnValueType>[];\n      data: Data;\n      metadata: ModelMetadata;\n    }\n  | {\n      columns: null;\n      rows: null;\n      data: null;\n      metadata: null;\n    };\n\nexport type TableResult<Data> = [\n  TableData<Data> & {\n    page: PaginationResult;\n    fetching: boolean;\n    error?: ErrorWrapper;\n    search: SearchResult;\n  },\n  refresh: (opts?: Partial<OperationContext>) => void\n];\n\n/**\n * Headless React hook for powering a table showing a page of Gadget records from the backend, optionally sorted, filtered, searched, and selected from. Returns a standard hook result set with a tuple of the result object with `data`, `fetching`, and `error` keys, and a `refetch` function. `data` will be a `GadgetRecordList` object holding the list of returned records and pagination info.\n *\n * @param manager Gadget model manager to use\n * @param options options for filtering and searching records, and selecting the fields in each record of the result\n *\n * @example\n *\n * ```\n * TODO\n * ```\n */\nexport const useTable = <\n  GivenOptions extends OptionsType,\n  SchemaT,\n  F extends FindManyFunction<GivenOptions, any, SchemaT, any>,\n  Options extends F[\"optionsType\"] & ReadOperationOptions & TableOptions\n>(\n  manager: { findMany: F },\n  options?: LimitToKnownKeys<Options, F[\"optionsType\"] & ReadOperationOptions & TableOptions>\n): TableResult<\n  GadgetRecord<Select<Exclude<F[\"schemaType\"], null | undefined>, DefaultSelection<F[\"selectionType\"], Options, F[\"defaultSelection\"]>>>[]\n> => {\n  const namespace = manager.findMany.namespace;\n  const namespaceAsArray: string[] = namespace ? (Array.isArray(namespace) ? namespace : [namespace]) : [];\n  const {\n    metadata,\n    fetching: fetchingMetadata,\n    error: metadataError,\n  } = useModelMetadata(manager.findMany.modelApiIdentifier, namespaceAsArray);\n\n  const fieldSelectionMap = useMemo(() => {\n    if (options?.select) return options.select;\n\n    if (!options?.columns) return undefined; // Use the default selection\n\n    const selectionMap: FieldSelection = {};\n    if (!metadata) return selectionMap;\n\n    for (const column of options.columns) {\n      if (typeof column === \"string\") {\n        selectionMap[column] = true;\n        continue;\n      }\n\n      if (isRelatedFieldColumn(column)) {\n        // We need to find the related model field from the metadata\n        // to determine whether the field is a has-one or has-many relationship,\n        // and build the correct selection map for it.\n        const fieldMetadata = metadata.fields.find((field) => field.apiIdentifier === column.field);\n        if (!fieldMetadata) {\n          throw new Error(`Field '${column.field}' not found in metadata`);\n        }\n\n        if (\n          fieldMetadata.configuration.__typename === \"GadgetHasOneConfig\" ||\n          fieldMetadata.configuration.__typename === \"GadgetBelongsToConfig\"\n        ) {\n          selectionMap[column.field] = {\n            [column.relatedField]: true,\n          };\n        } else {\n          selectionMap[column.field] = {\n            edges: {\n              node: {\n                [column.relatedField]: true,\n              },\n            },\n          };\n        }\n      }\n    }\n\n    return selectionMap;\n  }, [metadata, options?.columns, options?.select]);\n\n  const [{ data, fetching: dataFetching, error: dataError, page, search }, refresh] = useList(manager, {\n    ...options,\n    select: fieldSelectionMap ? { ...fieldSelectionMap, id: true } : undefined,\n    pause: !metadata, // Don't fetch data until metadata is loaded\n  } as any);\n\n  const fields = useMemo(\n    () =>\n      filterAutoTableFieldList(metadata?.fields, {\n        ...options,\n        include: fieldSelectionMap && Object.keys(fieldSelectionMap),\n      }),\n    [fieldSelectionMap, metadata?.fields, options]\n  );\n\n  const columns: TableColumn[] = useMemo(() => {\n    const columnsMap =\n      options?.columns &&\n      new Map(\n        options.columns.map((column) => {\n          if (isRelatedFieldColumn(column)) {\n            return [column.field, column.relatedField];\n          } else {\n            return [column, undefined];\n          }\n        })\n      );\n\n    return fields.map((field) => {\n      let relatedField: TableColumn | undefined;\n      const relatedFieldColumn = columnsMap?.get(field.apiIdentifier);\n\n      if (relatedFieldColumn) {\n        if (\n          field.fieldType !== GadgetFieldType.HasOne &&\n          field.fieldType !== GadgetFieldType.BelongsTo &&\n          field.fieldType !== GadgetFieldType.HasMany\n        ) {\n          throw new Error(`Field '${field.apiIdentifier}' is not a relationship field`);\n        }\n\n        const relatedFieldMetadata =\n          field.configuration.__typename === \"GadgetHasOneConfig\" ||\n          field.configuration.__typename === \"GadgetBelongsToConfig\" ||\n          field.configuration.__typename === \"GadgetHasManyConfig\"\n            ? field.configuration.relatedModel?.fields?.find((relatedField) => relatedField.apiIdentifier === relatedFieldColumn)\n            : undefined;\n\n        if (!relatedFieldMetadata) {\n          throw new Error(`Related field '${relatedFieldColumn}' not found in metadata`);\n        }\n\n        relatedField = {\n          name: relatedFieldMetadata.name,\n          apiIdentifier: relatedFieldMetadata.apiIdentifier,\n          fieldType: relatedFieldMetadata.fieldType,\n          getValue: (record: GadgetRecord<any>) => {\n            return record[field.apiIdentifier]?.[relatedFieldMetadata.apiIdentifier];\n          },\n          sortable: false,\n        };\n      }\n\n      return {\n        name: field.name,\n        apiIdentifier: field.apiIdentifier,\n        fieldType: field.fieldType,\n        getValue: (record: GadgetRecord<any>) => {\n          return record[field.apiIdentifier];\n        },\n        sortable: \"sortable\" in field && field.sortable,\n        relatedField,\n      } as TableColumn;\n    });\n  }, [fields, options?.columns]);\n\n  const isAwaitingDebouncedSearchValue = search.value != search.debouncedValue;\n  const fetching = dataFetching || fetchingMetadata || isAwaitingDebouncedSearchValue;\n  const error = dataError || metadataError;\n\n  return [\n    {\n      ...getTableData({ metadata, data, columns }),\n      page,\n      fetching,\n      error,\n      search,\n    },\n    refresh,\n  ];\n};\n\nconst getTableData = (props: { columns?: TableColumn[]; data?: GadgetRecord<any>[]; metadata?: ModelMetadata }) => {\n  const { columns, data, metadata } = props;\n\n  return metadata && data && columns\n    ? {\n        rows: getRows({ data, columns }),\n        columns,\n        data,\n        metadata,\n      }\n    : {\n        rows: null,\n        columns: null,\n\n        data: null,\n        metadata: null,\n      };\n};\n\nconst getRows = (props: { data: GadgetRecord<any>[]; columns: TableColumn[] }) => {\n  const { columns, data } = props;\n\n  return data.map((record) => {\n    const row: Record<string, ColumnValueType> = { id: record.id };\n    for (const { apiIdentifier, getValue } of columns) {\n      row[apiIdentifier] = getValue(record);\n    }\n    return row;\n  });\n};\n"]}