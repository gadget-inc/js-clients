{"version":3,"file":"useTable.js","sourceRoot":"","sources":["../../src/useTable.tsx"],"names":[],"mappings":"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","sourcesContent":["import type { FieldSelection } from \"@gadgetinc/api-client-core\";\nimport {\n  type DefaultSelection,\n  type FindManyFunction,\n  type GadgetRecord,\n  type LimitToKnownKeys,\n  type Select,\n} from \"@gadgetinc/api-client-core\";\nimport { useMemo } from \"react\";\nimport { filterAutoTableFieldList, useModelMetadata } from \"./metadata.js\";\nimport { useList } from \"./useList.js\";\nimport { getTableColumns, getTableData } from \"./useTableUtils/helpers.js\";\nimport type { TableOptions, TableResult } from \"./useTableUtils/types.js\";\nimport { isRelatedFieldColumn, type OptionsType, type ReadOperationOptions } from \"./utils.js\";\n\n/**\n * Headless React hook for powering a table showing a page of Gadget records from the backend, optionally sorted, filtered, searched, and selected from. Returns a standard hook result set with a tuple of the result object with `data`, `fetching`, and `error` keys, and a `refetch` function. `data` will be a `GadgetRecordList` object holding the list of returned records and pagination info.\n *\n * @param manager Gadget model manager to use\n * @param options options for filtering and searching records, and selecting the fields in each record of the result\n *\n * @example\n *\n * ```\n * TODO\n * ```\n */\nexport const useTable = <\n  GivenOptions extends OptionsType,\n  SchemaT,\n  F extends FindManyFunction<GivenOptions, any, SchemaT, any>,\n  Options extends F[\"optionsType\"] & ReadOperationOptions & TableOptions\n>(\n  manager: { findMany: F },\n  options?: LimitToKnownKeys<Options, F[\"optionsType\"] & ReadOperationOptions & TableOptions>\n): TableResult<\n  GadgetRecord<Select<Exclude<F[\"schemaType\"], null | undefined>, DefaultSelection<F[\"selectionType\"], Options, F[\"defaultSelection\"]>>>[]\n> => {\n  const namespace = manager.findMany.namespace;\n  const namespaceAsArray: string[] = namespace ? (Array.isArray(namespace) ? namespace : [namespace]) : [];\n  const {\n    metadata,\n    fetching: fetchingMetadata,\n    error: metadataError,\n  } = useModelMetadata(manager.findMany.modelApiIdentifier, namespaceAsArray);\n\n  const fieldSelectionMap = useMemo(() => {\n    if (options?.select) return options.select;\n\n    if (!options?.columns) return undefined; // Use the default selection\n\n    const selectionMap: FieldSelection = {};\n    if (!metadata) return selectionMap;\n\n    for (const column of options.columns) {\n      if (typeof column === \"string\") {\n        selectionMap[column] = true;\n        continue;\n      }\n\n      if (isRelatedFieldColumn(column)) {\n        // We need to find the related model field from the metadata\n        // to determine whether the field is a has-one or has-many relationship,\n        // and build the correct selection map for it.\n        const fieldMetadata = metadata.fields.find((field) => field.apiIdentifier === column.field);\n        if (!fieldMetadata) {\n          throw new Error(`Field '${column.field}' not found in metadata`);\n        }\n\n        if (\n          fieldMetadata.configuration.__typename === \"GadgetHasOneConfig\" ||\n          fieldMetadata.configuration.__typename === \"GadgetBelongsToConfig\"\n        ) {\n          selectionMap[column.field] = {\n            [column.relatedField]: true,\n          };\n        } else {\n          selectionMap[column.field] = {\n            edges: {\n              node: {\n                [column.relatedField]: true,\n              },\n            },\n          };\n        }\n      }\n    }\n\n    return selectionMap;\n  }, [metadata, options?.columns, options?.select]);\n\n  const [{ data, fetching: dataFetching, error: dataError, page, search }, refresh] = useList(manager, {\n    ...options,\n    select: fieldSelectionMap ? { ...fieldSelectionMap, id: true } : undefined,\n    pause: !metadata, // Don't fetch data until metadata is loaded\n  } as any);\n\n  const fields = useMemo(\n    () =>\n      filterAutoTableFieldList(metadata?.fields, {\n        ...options,\n        include: fieldSelectionMap && Object.keys(fieldSelectionMap),\n      }),\n    [fieldSelectionMap, metadata?.fields, options]\n  );\n\n  const columns = useMemo(() => {\n    return getTableColumns(fields, options?.columns);\n  }, [fields, options?.columns]);\n\n  const isAwaitingDebouncedSearchValue = search.value != search.debouncedValue;\n  const fetching = dataFetching || fetchingMetadata || isAwaitingDebouncedSearchValue;\n  const error = dataError || metadataError;\n\n  const tableData = useMemo(() => getTableData({ metadata, data, columns }), [metadata, data, columns]);\n\n  return [\n    {\n      ...tableData,\n      page,\n      fetching,\n      error,\n      search,\n    },\n    refresh,\n  ];\n};\n"]}