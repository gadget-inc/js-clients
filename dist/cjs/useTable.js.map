{"version":3,"file":"useTable.js","sourceRoot":"","sources":["../../src/useTable.tsx"],"names":[],"mappings":"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","sourcesContent":["import type {\n  DefaultSelection,\n  FindManyFunction,\n  GadgetRecord,\n  GadgetRecordList,\n  LimitToKnownKeys,\n  Select,\n} from \"@gadgetinc/api-client-core\";\nimport type { OperationContext } from \"@urql/core\";\nimport type { ReactNode } from \"react\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport type { GadgetFieldType } from \"./internal/gql/graphql.js\";\nimport type { ModelMetadata } from \"./metadata.js\";\nimport { FieldType, filterFieldList, useModelMetadata } from \"./metadata.js\";\nimport { useFindMany } from \"./useFindMany.js\";\nimport type { ErrorWrapper, OptionsType, ReadOperationOptions } from \"./utils.js\";\n\nexport interface TableColumn {\n  name: string;\n  apiIdentifier: string;\n  fieldType: GadgetFieldType;\n  getValue: (record: GadgetRecord<any>) => ReactNode;\n  sortable: boolean;\n}\n\nexport interface TablePagination {\n  hasNextPage: boolean | undefined;\n  hasPreviousPage: boolean | undefined;\n  variables: {\n    first?: number;\n    after?: string;\n    last?: number;\n    before?: string;\n  };\n  pageSize: number;\n  goToNextPage(): void;\n  goToPreviousPage(): void;\n}\n\nexport interface TableOptions {\n  pageSize?: number;\n  initialCursor?: string;\n  initialDirection?: \"forward\" | \"backward\";\n  include?: string[];\n  exclude?: string[];\n  fields?: string[];\n}\n\nexport type TableResult<Data> = [\n  (\n    | {\n        columns: TableColumn[];\n        rows: Record<string, ReactNode>[];\n        data: Data;\n        page: TablePagination;\n        metadata: ModelMetadata;\n        fetching: boolean;\n        error?: ErrorWrapper;\n      }\n    | { columns: null; rows: null; data: null; metadata: null; page: TablePagination; fetching: boolean; error?: ErrorWrapper }\n  ),\n  (opts?: Partial<OperationContext>) => void\n];\n\n/**\n * Headless React hook for powering a table showing a page of Gadget records from the backend, optionally sorted, filtered, searched, and selected from. Returns a standard hook result set with a tuple of the result object with `data`, `fetching`, and `error` keys, and a `refetch` function. `data` will be a `GadgetRecordList` object holding the list of returned records and pagination info.\n *\n * @param manager Gadget model manager to use\n * @param options options for filtering and searching records, and selecting the fields in each record of the result\n *\n * @example\n *\n * ```\n * TODO\n * ```\n */\nexport const useTable = <\n  GivenOptions extends OptionsType,\n  SchemaT,\n  F extends FindManyFunction<GivenOptions, any, SchemaT, any>,\n  Options extends F[\"optionsType\"] & ReadOperationOptions & TableOptions\n>(\n  manager: { findMany: F },\n  options?: LimitToKnownKeys<Options, F[\"optionsType\"] & ReadOperationOptions & TableOptions>\n): TableResult<\n  GadgetRecordList<Select<Exclude<F[\"schemaType\"], null | undefined>, DefaultSelection<F[\"selectionType\"], Options, F[\"defaultSelection\"]>>>\n> => {\n  const [cursor, setCursor] = useState<string | undefined>(options?.initialCursor);\n  const [direction, setDirection] = useState<\"forward\" | \"backward\">(options?.initialDirection ?? \"forward\");\n  const pageSize = options?.pageSize ?? 50;\n\n  let variables;\n  if (direction == \"forward\") {\n    variables = {\n      first: pageSize,\n      after: cursor,\n    };\n  } else {\n    variables = {\n      last: pageSize,\n      before: cursor,\n    };\n  }\n  // we always need to select the record id for key tracking, add `id`. only add it if there's an explicit selection\n  let select = options?.select ? options.select : null;\n  if (select) {\n    select = { ...select, id: true };\n  }\n\n  const [{ data, fetching: dataFetching, error: dataError }, refresh] = useFindMany(manager, {\n    ...options,\n    ...(variables as any),\n    select,\n  });\n\n  const { metadata: metadata, fetching: fetchingMetadata, error: metadataError } = useModelMetadata(manager.findMany.modelApiIdentifier);\n  const fields = useMemo(() => filterFieldList(metadata?.fields, options), [metadata?.fields, options]);\n\n  const columns: TableColumn[] = useMemo(\n    () =>\n      fields.map((field) => ({\n        name: field.name,\n        apiIdentifier: field.apiIdentifier,\n        fieldType: field.fieldType,\n        getValue: (record: GadgetRecord<any>) => {\n          const value = record[field.apiIdentifier];\n          switch (field.fieldType) {\n            case FieldType.DateTime: {\n              return value?.toLocaleString();\n            }\n            default: {\n              return value;\n            }\n          }\n        },\n        sortable: \"sortable\" in field && field.sortable,\n      })),\n    [fields]\n  );\n\n  const goToNextPage = useCallback(() => {\n    if (data && data.hasNextPage) {\n      setDirection(\"forward\");\n      setCursor(data.endCursor);\n    } else {\n      console.warn(\"can't navigate to next page currently, no next page available\");\n    }\n  }, [data]);\n\n  const goToPreviousPage = useCallback(() => {\n    if (data && data.hasPreviousPage) {\n      setDirection(\"backward\");\n      setCursor(data.startCursor);\n    } else {\n      console.warn(\"can't navigate to previous page currently, no previous page available\");\n    }\n  }, [data]);\n\n  const fetching = dataFetching || fetchingMetadata;\n  const error = dataError || metadataError;\n  const page: TablePagination = {\n    goToNextPage,\n    goToPreviousPage,\n    variables,\n    pageSize,\n    hasNextPage: data?.hasNextPage,\n    hasPreviousPage: data?.hasPreviousPage,\n  };\n\n  if (metadata && data && columns) {\n    const rows = data.map((record) => {\n      const row: Record<string, ReactNode> = { id: (record as any).id };\n      for (const { apiIdentifier, getValue } of columns) {\n        row[apiIdentifier] = getValue(record);\n      }\n      return row;\n    });\n    return [{ rows, columns, data, metadata, page, fetching, error }, refresh];\n  } else {\n    return [{ rows: null, columns: null, data: null, metadata: null, page, fetching, error }, refresh];\n  }\n};\n"]}