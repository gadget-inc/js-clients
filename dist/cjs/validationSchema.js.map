{"version":3,"file":"validationSchema.js","sourceRoot":"","sources":["../../src/validationSchema.tsx"],"names":[],"mappings":"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","sourcesContent":["import type { ISchema } from \"yup\";\nimport { array, boolean, date, mixed, number, object, string } from \"yup\";\nimport type { GadgetEnumConfig, GadgetObjectFieldConfig } from \"./internal/gql/graphql\";\nimport { GadgetFieldType } from \"./internal/gql/graphql\";\nimport type { FieldMetadata } from \"./metadata\";\n\nconst fileInputValidator = object({\n  base64: string(),\n  copyURL: string(),\n  directUploadToken: string(),\n  mimeType: string(),\n  fileName: string(),\n  file: object(),\n});\n\nconst richTextInputValidator = object({\n  markdown: string().required(),\n});\n\nconst validatorForField = (field: FieldMetadata) => {\n  let validator;\n  switch (field.fieldType) {\n    case GadgetFieldType.Boolean: {\n      validator = boolean();\n      break;\n    }\n    case GadgetFieldType.Code:\n    case GadgetFieldType.Password:\n    case GadgetFieldType.EncryptedString:\n    case GadgetFieldType.Color:\n    case GadgetFieldType.String: {\n      validator = string();\n      break;\n    }\n    case GadgetFieldType.DateTime: {\n      validator = date();\n      break;\n    }\n    case GadgetFieldType.Email: {\n      validator = string().email();\n      break;\n    }\n    case GadgetFieldType.Url: {\n      validator = string().url();\n      break;\n    }\n    case GadgetFieldType.Enum: {\n      const config = field.configuration as GadgetEnumConfig;\n      const element = string().oneOf(config.options.map((option) => option.name));\n      if (config.allowMultiple) {\n        validator = array(element);\n      } else {\n        validator = element;\n      }\n      break;\n    }\n    case GadgetFieldType.File: {\n      validator = fileInputValidator;\n      break;\n    }\n    case GadgetFieldType.Number: {\n      validator = number();\n      break;\n    }\n    case GadgetFieldType.Id: {\n      validator = string();\n      break;\n    }\n    case GadgetFieldType.RecordState:\n    case GadgetFieldType.Any:\n    case GadgetFieldType.Json: {\n      validator = mixed();\n      break;\n    }\n    case GadgetFieldType.Money: {\n      validator = string();\n      break;\n    }\n    case GadgetFieldType.Object: {\n      const config = field.configuration as GadgetObjectFieldConfig;\n      validator = validationSchema(config.fields as any);\n      break;\n    }\n    case GadgetFieldType.RichText: {\n      validator = richTextInputValidator;\n      break;\n    }\n    case GadgetFieldType.RoleAssignments: {\n      validator = array(string());\n      break;\n    }\n    case GadgetFieldType.Vector: {\n      validator = array(number());\n      break;\n    }\n    case GadgetFieldType.BelongsTo:\n    case GadgetFieldType.HasOne:\n    case GadgetFieldType.HasManyThrough:\n    case GadgetFieldType.HasMany: {\n      // TODO: implement relationship validations\n      validator = object();\n      break;\n    }\n    default: {\n      throw new Error(`unknown field type ${field.fieldType} for validator generation`);\n    }\n  }\n\n  if (field.requiredArgumentForInput) {\n    validator = validator.required();\n  } else {\n    validator = (validator.nullable() as any).default(null);\n  }\n\n  return validator;\n};\n\n/**\n * Build a Yup validation schema given some fields metadata for validating that a data object conforms to the schema at runtime\n */\nexport const validationSchema = (fields: FieldMetadata[]) => {\n  const validators: Record<string, ISchema<any>> = {};\n  for (const field of fields) {\n    validators[field.apiIdentifier] = validatorForField(field);\n  }\n  return object(validators);\n};\n"]}