{"version":3,"file":"AutoForm.js","sourceRoot":"","sources":["../../../src/auto/AutoForm.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ActionFunction,\n  DeepFilterNever,\n  FieldSelection,\n  GadgetRecord,\n  GlobalActionFunction,\n  Select,\n} from \"@gadgetinc/api-client-core\";\nimport { yupResolver } from \"@hookform/resolvers/yup\";\nimport type { ReactNode } from \"react\";\nimport React, { useEffect, useMemo, useRef } from \"react\";\nimport type { GadgetHasManyThroughConfig, GadgetObjectFieldConfig } from \"../internal/gql/graphql.js\";\nimport type { FieldMetadata, GlobalActionMetadata, ModelWithOneActionMetadata } from \"../metadata.js\";\nimport { FieldType, buildAutoFormFieldList, isModelActionMetadata, useActionMetadata } from \"../metadata.js\";\nimport type {\n  AnyActionWithId,\n  AnyUpsertAction,\n  RecordIdentifier,\n  UseActionFormHookStateData,\n  UseActionFormSubmit,\n} from \"../use-action-form/types.js\";\nimport { isPlainObject, processDefaultValues, toDefaultValues } from \"../use-action-form/utils.js\";\nimport { getRelatedModelFields, isHasManyOrHasManyThroughField, isRelationshipField, pathListToSelection } from \"../use-table/helpers.js\";\nimport type { FieldErrors, FieldValues, UseFormReturn } from \"../useActionForm.js\";\nimport { useActionForm } from \"../useActionForm.js\";\nimport { get, getFlattenedObjectKeys, set, type ErrorWrapper, type OptionsType } from \"../utils.js\";\nimport { validationSchema } from \"../validationSchema.js\";\nimport {\n  validateFindByObjectWithMetadata,\n  validateNonBulkAction,\n  validateTriggersFromApiClient,\n  validateTriggersFromMetadata,\n} from \"./AutoFormActionValidators.js\";\nimport { useAssertNotNestedInAnotherAutoForm, useFieldsFromChildComponents } from \"./AutoFormContext.js\";\nimport { isAutoInput } from \"./AutoInput.js\";\nimport { getSelectedPathsFromOptionLabel } from \"./hooks/useSelectedPathsFromRecordLabel.js\";\nimport { getOptionLabelsFromRecordLabel, type RecordLabel } from \"./interfaces/AutoRelationshipInputProps.js\";\n\n/** When the AutoForm does not have children, these properties are available to control the rendering of the form */\ntype AutoFormPropsWithoutChildren = {\n  children?: never;\n\n  /** The title at the top of the form. False to omit */\n  title?: string | false;\n\n  /** The label to use for the submit button at the bottom of the form */\n  submitLabel?: ReactNode;\n};\n\ntype AutoFormPropsWithChildren = {\n  /** Custom components to render within the form. Using this will override all default field rendering.   */\n  children?: ReactNode;\n};\n\n/** Helper type for the record shape in AutoFormProps */\ntype AutoFormRecordType<ActionFunc> = ActionFunc extends {\n  schemaType: infer SchemaType;\n  defaultSelection: infer DefaultSelection extends FieldSelection | null | undefined;\n}\n  ? GadgetRecord<\n      { id: string } & (SchemaType extends null | undefined ? unknown : Partial<DeepFilterNever<Select<SchemaType, DefaultSelection>>>)\n    >\n  : never;\n\n/** The props that any <AutoForm/> component accepts */\nexport type AutoFormProps<\n  GivenOptions extends OptionsType,\n  SchemaT,\n  ActionFunc extends ActionFunction<GivenOptions, any, any, SchemaT, any> | GlobalActionFunction<any>,\n  ExtraFormVariables extends FieldValues = Record<string, unknown>,\n  DefaultValues = Partial<ActionFunc[\"variablesType\"]> & ExtraFormVariables\n> = (AutoFormPropsWithChildren | AutoFormPropsWithoutChildren) & {\n  /** Which action this fom will run on submit */\n  action: ActionFunc;\n  /** What to show the user once the form has been submitted successfully */\n  successContent?: ReactNode;\n  /** The loading skeleton to display when the form is loading */\n  loadingSkeleton?: ReactNode;\n  /** An allowlist of fields to render within the form. Only these fields will be rendered as inputs. */\n  include?: string[];\n  /** A denylist of fields to render within the form. Every field except these fields will be rendered as inputs. */\n  exclude?: string[];\n  /** A set of field values to pre-populate the form with on load. Only applies to create forms. */\n  defaultValues?: DefaultValues;\n  /** Selection object to pass to the form to retrieve existing values. This will override the default selection based on included fields */\n  select?: GivenOptions[\"select\"];\n  /** Called when the form submission completes successfully on the backend */\n  onSuccess?: (record: UseActionFormHookStateData<ActionFunc>) => void;\n  /** Called when the form submission errors before sending, during the API call, or if the API call returns an error. */\n  onFailure?: (error: Error | FieldErrors<ActionFunc[\"variablesType\"]>) => void;\n  /** Enable debug logging for this form */\n  debug?: boolean;\n} & (ActionFunc extends AnyActionWithId<GivenOptions>\n    ?\n        | {\n            /**\n             * The record identifier to run this action on, if it already exists.\n             * Should be undefined for create actions, or a record ID (or finder) for update / etc actions\n             **/\n            findBy: RecordIdentifier;\n            /** If a findBy is provided, you can't pass a record option */\n            record?: never;\n          }\n        | {\n            /**\n             * If a record is provided, you can't pass a findBy option\n             **/\n            findBy?: never;\n            /** A record for this form to act on; will be merged with the default values */\n            record: AutoFormRecordType<ActionFunc>;\n          }\n    : ActionFunc extends AnyUpsertAction\n    ?\n        | {\n            /**\n             * The record identifier to run this action on, if it already exists.\n             * Should be undefined for create actions, or a record ID (or finder) for update / etc actions\n             **/\n            findBy?: RecordIdentifier;\n            /** If a findBy is provided, you can't pass a record option */\n            record?: never;\n          }\n        | {\n            /**\n             * If a record is provided, you can't pass a findBy option\n             **/\n            findBy?: never;\n            /** A record for this form to act on; will be merged with the default values */\n            record?: AutoFormRecordType<ActionFunc>;\n          }\n    : {\n        /** This action doesn't run against existing records, so you can't pass a findBy option */\n        findBy?: never;\n        /** This action doesn't operate with a record, so you can't pass a record option */\n        record?: never;\n      });\n\n/**\n * React hook for getting the validation schema for a list of fields\n */\nconst useValidationResolver = (metadata: ModelWithOneActionMetadata | GlobalActionMetadata | undefined, pathsToValidate: string[]) => {\n  return useMemo(() => {\n    if (!metadata) return undefined;\n    const action = isModelActionMetadata(metadata) ? metadata.action : metadata;\n    return yupResolver(validationSchema(action.inputFields, pathsToValidate));\n  }, [metadata, pathsToValidate]);\n};\n\nconst isMetadataForUpsertAction = (metadata: ModelWithOneActionMetadata | GlobalActionMetadata | undefined | null) => {\n  if (!metadata) {\n    return undefined;\n  }\n\n  if (!isModelActionMetadata(metadata)) {\n    // Global actions can never be upsert\n    return false;\n  }\n\n  return metadata.action.isUpsertMetaAction;\n};\n\n/**\n * React hook for getting a list of fields to use in a form (given include/exclude options)\n */\nexport const useFormFields = (\n  metadata: ModelWithOneActionMetadata | GlobalActionMetadata | undefined | null,\n  options: { include?: string[]; exclude?: string[] }\n): readonly { path: string; metadata: FieldMetadata }[] => {\n  return useMemo(() => {\n    if (!metadata) return [];\n    const action = isModelActionMetadata(metadata) ? metadata.action : metadata;\n\n    const isModelMetadata = metadata.__typename === \"GadgetModel\";\n\n    const objectFields = isModelMetadata\n      ? action.inputFields.filter(\n          (field) => field.configuration.__typename === \"GadgetObjectFieldConfig\" && field.apiIdentifier === metadata.apiIdentifier\n        )\n      : [];\n    const nonObjectFields = action.inputFields.filter((field) => field.configuration.__typename !== \"GadgetObjectFieldConfig\");\n\n    const includedRootLevelFields = buildAutoFormFieldList(nonObjectFields, options as any).map(\n      ([path, field]) =>\n        ({\n          path,\n          metadata: field,\n        } as const)\n    );\n\n    const includedObjectFields = objectFields.flatMap((objectField) =>\n      buildAutoFormFieldList((objectField.configuration as unknown as GadgetObjectFieldConfig).fields as any, {\n        ...(options as any),\n        isUpsertAction: true, // For upsert meta-actions, we allow IDs, and they are object fields instead of root level\n      }).map(\n        ([innerPath, innerField]) =>\n          ({\n            path: `${objectField.apiIdentifier}.${innerPath}`,\n            metadata: innerField,\n          } as const)\n      )\n    );\n\n    const allFormFields = [...includedObjectFields, ...includedRootLevelFields];\n    validateFormFieldApiIdentifierUniqueness(action.apiIdentifier, allFormFields);\n\n    return allFormFields;\n  }, [metadata, options]);\n};\n\nconst useFormSelection = (props: {\n  modelApiIdentifier: string | undefined;\n  rootFieldsMetadata: FieldMetadata[];\n  fields: readonly { path: string; metadata: FieldMetadata }[]; // From smart selection through child parsing and AutoInput registration\n  select?: FieldSelection;\n}): FieldSelection | undefined => {\n  const { modelApiIdentifier, fields, select, rootFieldsMetadata } = props;\n\n  const selectFromProps = useMemo(() => {\n    if (!select || !modelApiIdentifier) {\n      return;\n    }\n    return forceIdsIntoSelect({ select, rootFieldsMetadata });\n  }, [select, modelApiIdentifier, rootFieldsMetadata]);\n\n  if (!modelApiIdentifier || !fields.length) {\n    return;\n  }\n\n  if (selectFromProps) {\n    return selectFromProps;\n  }\n\n  const paths = fields.map((f) => f.path.replace(new RegExp(`^${modelApiIdentifier}\\\\.`), \"\"));\n  const fieldMetaData = fields.map((f) => f.metadata);\n\n  return pathListToSelection(modelApiIdentifier, paths, fieldMetaData);\n};\n\nconst forceIdsIntoSelect = (props: { select: FieldSelection; rootFieldsMetadata: FieldMetadata[] }) => {\n  const { select: originalSelect, rootFieldsMetadata } = props;\n  const select = structuredClone(originalSelect);\n\n  select.id = true; // Always select the ID for the root model\n\n  const addIdToSelection = (selectPath: string, fieldMetadata: FieldMetadata) => {\n    if (!isRelationshipField(fieldMetadata)) {\n      return; // Non relationships do not need additional selection\n    }\n\n    const existingSelection = get(select, selectPath);\n    if (!existingSelection || typeof existingSelection !== \"object\") {\n      // Do not go deeper than what is defined in the select object\n      return;\n    }\n\n    const isManyRelation = isHasManyOrHasManyThroughField(fieldMetadata);\n    const currentFieldSelectPathPrefix = isManyRelation ? `${selectPath}.edges.node` : `${selectPath}`;\n    const idPath = `${currentFieldSelectPathPrefix}.id`;\n\n    set(select, idPath, true);\n\n    const relatedModelFields = getRelatedModelFields(fieldMetadata);\n\n    for (const relatedModelField of relatedModelFields) {\n      addIdToSelection(`${currentFieldSelectPathPrefix}.${relatedModelField.apiIdentifier}`, relatedModelField);\n    }\n  };\n\n  for (const field of rootFieldsMetadata) {\n    addIdToSelection(field.apiIdentifier, field);\n  }\n\n  return select;\n};\n\nconst validateFormFieldApiIdentifierUniqueness = (\n  actionApiIdentifier: string,\n  inputApiIdentifiers: { path: string; metadata: FieldMetadata }[]\n) => {\n  const seenPaths = new Set<string>();\n  const seenMetadataApiIds = new Set<string>();\n\n  // Sorted by length because longer names need to be checked later against the shorter names\n  const sortedInputApiIdentifiers = [...inputApiIdentifiers].sort((a, b) => a.path.length - b.path.length);\n  for (const { path, metadata } of sortedInputApiIdentifiers) {\n    const hasSeenPaths = seenPaths.has(path);\n    if (hasSeenPaths) {\n      throw new Error(`Input \"${metadata.apiIdentifier}\" is not unique for action \"${actionApiIdentifier}\"`);\n    }\n\n    const hasSeenMetadataApiIds = seenMetadataApiIds.has(metadata.apiIdentifier);\n    if (hasSeenMetadataApiIds) {\n      // Disallow custom params that match model field api IDs\n      const prefixRemovedPath = hasSeenMetadataApiIds ? path.replace(`${path.split(\".\")[0]}.`, \"\") : \"\";\n      const hasSeenPrefixRemovedPath = prefixRemovedPath && seenPaths.has(prefixRemovedPath);\n      if (hasSeenPrefixRemovedPath) {\n        throw new Error(`Input \"${metadata.apiIdentifier}\" is not unique for action \"${actionApiIdentifier}\"`);\n      }\n    }\n    seenMetadataApiIds.add(metadata.apiIdentifier);\n    seenPaths.add(path);\n  }\n};\n\n/**\n * Internal React hook for sharing logic between different `AutoForm` components.\n * @internal\n */\nexport const useAutoForm = <\n  GivenOptions extends OptionsType,\n  SchemaT,\n  ActionFunc extends ActionFunction<GivenOptions, any, any, SchemaT, any> | GlobalActionFunction<any>\n>(\n  props: AutoFormProps<GivenOptions, SchemaT, ActionFunc>\n): {\n  select?: GivenOptions[\"select\"];\n  metadata: ModelWithOneActionMetadata | GlobalActionMetadata | undefined;\n  fetchingMetadata: boolean;\n  metadataError: ErrorWrapper | undefined;\n  fields: readonly { path: string; metadata: FieldMetadata }[];\n  submit: UseActionFormSubmit<ActionFunc>;\n  formError: Error | ErrorWrapper | null | undefined;\n  isSubmitting: boolean;\n  isSubmitSuccessful: boolean;\n  pauseExistingRecordLookup: boolean;\n  isLoading: boolean;\n  originalFormMethods: UseFormReturn<any, any>;\n} => {\n  const { action, record, onSuccess, onFailure, findBy, select } = props;\n\n  useAssertNotNestedInAnotherAutoForm();\n  validateNonBulkAction(action);\n  validateTriggersFromApiClient(action);\n\n  let include = props.include;\n  let exclude = props.exclude;\n\n  const { metadata, fetching: fetchingMetadata, error: metadataError } = useActionMetadata(props.action);\n\n  validateTriggersFromMetadata(metadata);\n\n  const rootFieldsMetadata = getRootFieldsFromMetadata(metadata);\n\n  const { hasCustomFormChildren, fieldSet, registerFields } = useFieldsFromChildComponents();\n  const hasRegisteredFieldsFromChildren = hasCustomFormChildren && fieldSet.size > 0;\n  const registeredFieldsFromChildren = hasCustomFormChildren\n    ? extractPathsFromChildren({\n        children: \"children\" in props ? props.children : undefined,\n        getFieldsToSelectOnRecordLabelCallback: (path) => getAllRelatedModelFieldApiIdentifiers({ path, rootFieldsMetadata }),\n      })\n    : [];\n\n  useEffect(() => {\n    registerFields(registeredFieldsFromChildren);\n  }, [registeredFieldsFromChildren.join(\",\"), registerFields]);\n\n  if (hasCustomFormChildren) {\n    include = Array.from(fieldSet);\n    exclude = undefined;\n  }\n\n  // filter down the fields to render only what we want to render for this form\n  const fields = useFormFields(metadata, { include, exclude });\n\n  validateFindByObjectWithMetadata(fields, findBy);\n  const isDeleteAction = metadata && isModelActionMetadata(metadata) && metadata.action.isDeleteAction;\n  const isGlobalAction = action.type === \"globalAction\";\n  const operatesWithRecordId = !!(metadata && isModelActionMetadata(metadata) && metadata.action.operatesWithRecordIdentity);\n  const modelApiIdentifier = action.type == \"action\" ? action.modelApiIdentifier : undefined;\n  const isUpsertMetaAction = isMetadataForUpsertAction(metadata);\n  const selection = useFormSelection({ modelApiIdentifier, rootFieldsMetadata, fields, select });\n  const isUpsertWithFindBy = isUpsertMetaAction && !!findBy;\n  const fieldPathsToValidate = useMemo(() => fields.map(({ path }) => path), [fields]);\n\n  const defaultValues: Record<string, unknown> = useMemo(() => {\n    let mergedDefaultValues: Record<string, unknown> | undefined = props.defaultValues;\n\n    if (action.type === \"action\" && record) {\n      const defaultValuesForModel: Record<string, unknown> = props.defaultValues?.[modelApiIdentifier!] ?? {};\n\n      const defaultValuesForRecord = toDefaultValues(undefined, record);\n\n      const id = defaultValuesForModel.id ?? props.defaultValues?.id ?? record?.id;\n\n      mergedDefaultValues = {\n        ...props.defaultValues,\n        [modelApiIdentifier!]: {\n          id,\n          ...defaultValuesForRecord,\n          ...Object.fromEntries(\n            Object.keys(defaultValuesForRecord).flatMap((key) =>\n              props.defaultValues && key in props.defaultValues ? [[key, props.defaultValues[key]]] : []\n            )\n          ),\n          ...defaultValuesForModel,\n        },\n        id,\n      };\n    }\n\n    return (\n      mergedDefaultValues ??\n      (action.type === \"globalAction\"\n        ? {}\n        : {\n            [modelApiIdentifier!]:\n              record ??\n              (!(operatesWithRecordId || isUpsertWithFindBy) && metadata && isModelActionMetadata(metadata) && metadata.defaultRecord),\n            id: record\n              ? record.id\n              : typeof findBy === \"string\"\n              ? findBy // ID is given directly\n              : undefined, // Set by the retrieved existing record if object based findBy value\n          })\n    );\n  }, [props.defaultValues, action.type, modelApiIdentifier, record, operatesWithRecordId, metadata, isUpsertWithFindBy, findBy]);\n\n  const pauseExistingRecordLookup =\n    record || !(\"findBy\" in props)\n      ? true // Always pause if a record is passed or no findBy. No need to do a lookup\n      : fetchingMetadata || !selection; // Pause until we have the field selection to include in the lookup\n\n  // setup the form state for the action\n  const {\n    submit,\n    error: formError,\n    reset,\n    setValue,\n    getValues,\n    findResult,\n    formState: { isSubmitSuccessful, submitCount, isLoading, isReady, isSubmitting, touchedFields, errors },\n    originalFormMethods,\n  } = useActionForm(action, {\n    defaultValues: defaultValues as any,\n    findBy: \"findBy\" in props ? props.findBy : undefined,\n    throwOnInvalidFindByObject: false,\n    pause: pauseExistingRecordLookup,\n    select: selection as any,\n    resolver: useValidationResolver(metadata, fieldPathsToValidate),\n    send: () => {\n      const hasManyFieldPaths = new Set(\n        fields.flatMap(({ path, metadata }) => {\n          if (metadata.fieldType === FieldType.HasMany || metadata.fieldType === FieldType.HasManyThrough) {\n            return path;\n          } else {\n            return [];\n          }\n        })\n      );\n\n      const hasManyThroughFieldMap: Record<string, string> = {};\n\n      for (const { path, metadata } of fields) {\n        if (metadata.fieldType === FieldType.HasManyThrough) {\n          const config = metadata.configuration as GadgetHasManyThroughConfig;\n          const pathParts = path.split(\".\");\n          const basePath = pathParts.slice(0, -1);\n          hasManyThroughFieldMap[path] = [...basePath, config.joinModelHasManyFieldApiIdentifier].join(\".\");\n        }\n      }\n\n      const fieldsToSend = fields\n        .filter(({ path, metadata }) => {\n          const fieldType = metadata.fieldType;\n          const isUntouchedPasswordField = fieldType === FieldType.Password && \"findBy\" in props && !get(touchedFields, path);\n          if (isUntouchedPasswordField) {\n            // Never send the password field if it hasn't been touched. Doing so will clear the record value\n            return false;\n          }\n\n          if (fieldType === FieldType.BelongsTo) {\n            const fullBelongsToValue = getValues(path);\n            const rawBelongsToValueId = getValues(`${path}Id`);\n            if (fullBelongsToValue === null && rawBelongsToValueId) {\n              // Here we have a belongsTo field that points to a related record that doesn't exist\n              // Do not send `belongsToField: null` to the backend because it will clear the belongsTo field\n              return false;\n            }\n          }\n\n          const pathParts = path.split(\".\");\n          const isChildOfHasManyField = pathParts.some((_, index) => {\n            const parentPath = pathParts.slice(0, index).join(\".\");\n            return hasManyFieldPaths.has(parentPath);\n          });\n\n          if (isChildOfHasManyField) {\n            return false;\n          }\n\n          if (props.include) {\n            return props.include?.includes(metadata.apiIdentifier);\n          } else if (props.exclude) {\n            return !props.exclude?.includes(metadata.apiIdentifier);\n          }\n          return true;\n        })\n        .map(({ path }) => path);\n\n      if (operatesWithRecordId) {\n        fieldsToSend.push(\"id\");\n      }\n\n      if (props.defaultValues && modelApiIdentifier) {\n        // Add any explicitly set default values to the fields to send in the event that they are not included\n        const explicityDefaultedPaths = getFlattenedObjectKeys(props.defaultValues);\n        explicityDefaultedPaths.forEach((path) => {\n          if (!fieldsToSend.includes(path)) {\n            fieldsToSend.push(path);\n          }\n        });\n      }\n\n      return fieldsToSend.map((field) => {\n        if (hasManyThroughFieldMap[field]) {\n          return hasManyThroughFieldMap[field];\n        }\n        return field;\n      });\n    },\n    onError: onFailure,\n    onSuccess,\n    debug: props.debug,\n  });\n\n  const isCreateAction = !operatesWithRecordId && !isDeleteAction && !isGlobalAction && !isUpsertMetaAction;\n  const isUpsertWithoutProvidedId = isUpsertMetaAction && !isUpsertWithFindBy && !record?.id;\n\n  // Post submit form reset\n  useEffect(() => {\n    if (isSubmitSuccessful) {\n      if (isCreateAction || isUpsertWithoutProvidedId || isGlobalAction) {\n        const resetValues =\n          modelApiIdentifier && selection ? resetValuesForDefaultValues(modelApiIdentifier, defaultValues, selection) : defaultValues;\n\n        reset(resetValues);\n      }\n    }\n  }, [\n    isSubmitSuccessful,\n    isCreateAction,\n    isUpsertWithoutProvidedId,\n    isGlobalAction,\n    reset,\n    defaultValues,\n    submitCount,\n    selection,\n    modelApiIdentifier,\n  ]);\n\n  // we don't have synchronous access to the default values always -- sometimes we need to load them from the metadata. if we do that, then we need to forcibly set them into the form state once they have been loaded\n  const hasSetInitialValues = useRef<boolean>(false);\n  useEffect(() => {\n    if (isReady && !hasSetInitialValues.current && modelApiIdentifier && defaultValues[modelApiIdentifier]) {\n      hasSetInitialValues.current = true;\n      originalFormMethods.reset(defaultValues);\n    }\n  }, [isReady, defaultValues, originalFormMethods, modelApiIdentifier]);\n\n  if (!fetchingMetadata) {\n    validateFindBy({ operatesWithRecordId, hasFindBy: !!findBy, isUpsertMetaAction: !!isUpsertMetaAction, record });\n  }\n\n  useEffect(() => {\n    if (isUpsertWithFindBy) {\n      setValue(`${modelApiIdentifier!}.id`, findBy); // Upsert actions use model.id instead of use root level api value\n    }\n  }, [getValues(`${modelApiIdentifier!}.id`), isUpsertWithFindBy]);\n\n  // Update the form state with the lookup result when the form conditional changes the set of registered AutoInputs\n  useEffect(() => {\n    if (!findBy || !hasRegisteredFieldsFromChildren || select || !action || !(\"modelApiIdentifier\" in action)) {\n      // No AutoInput children need to be updated\n      return;\n    }\n\n    if (!findResult || findResult.fetching || findResult.error || !findResult.data) {\n      return;\n    }\n\n    const newDefaultValues = processDefaultValues({\n      data: findResult.data,\n      defaultValues: props.defaultValues,\n      modelApiIdentifier: action.modelApiIdentifier,\n      hasAmbiguousDefaultValues: action.hasAmbiguousIdentifier ?? false,\n    });\n\n    reset(newDefaultValues, { keepDirtyValues: true, keepTouched: true });\n  }, [Array.from(fieldSet).join(\",\"), findResult?.fetching]);\n\n  return {\n    metadata,\n    fetchingMetadata,\n    metadataError,\n    fields: fields.filter(\n      (field) =>\n        falseForIdFieldsUnlessUpsertWithoutFindBy({ isUpsertWithFindBy, metadata: field.metadata }) &&\n        !isJoinModelHasManyField(field.metadata)\n    ),\n    submit,\n    formError,\n    pauseExistingRecordLookup,\n    isSubmitting,\n    isSubmitSuccessful,\n    isLoading,\n    originalFormMethods,\n  };\n};\n\nconst resetValuesForDefaultValues = (modelApiIdentifier: string, defaultValues: Record<string, unknown>, selection: FieldSelection) => {\n  const extractResetArrayPathsFromSelection = (selection: FieldSelection) => {\n    return Object.keys(selection).reduce<any>((acc, key) => {\n      const selectionValue = selection[key];\n\n      if (isPlainObject(selectionValue)) {\n        if (\"edges\" in selectionValue) {\n          acc[key] = [];\n        } else {\n          const subSelectionValue = extractResetArrayPathsFromSelection(selectionValue);\n          if (Object.keys(subSelectionValue).length > 0) {\n            acc[key] = subSelectionValue;\n          }\n        }\n      }\n\n      return acc;\n    }, {});\n  };\n\n  return {\n    ...defaultValues,\n    [modelApiIdentifier]: {\n      ...(defaultValues[modelApiIdentifier] ?? {}),\n      ...extractResetArrayPathsFromSelection(selection),\n    },\n  };\n};\n\nconst extractPathsFromChildren = (props: {\n  children: React.ReactNode;\n  currentPath?: string;\n  getFieldsToSelectOnRecordLabelCallback?: (path: string) => string[];\n}) => {\n  const { children, currentPath, getFieldsToSelectOnRecordLabelCallback } = props;\n\n  const paths = new Set<string>();\n\n  React.Children.forEach(children, (child) => {\n    if (React.isValidElement(child)) {\n      const grandChildren = child.props.children as React.ReactNode | undefined;\n      let childPaths: string[] = [];\n\n      const newCurrentPath = currentPath && child.props.field ? currentPath + \".\" + child.props.field : child.props.field;\n\n      if (grandChildren) {\n        childPaths = extractPathsFromChildren({\n          children: grandChildren,\n          currentPath: newCurrentPath,\n          getFieldsToSelectOnRecordLabelCallback,\n        });\n      }\n\n      let field: string | undefined = undefined;\n\n      if (isAutoInput(child)) {\n        const props = child.props as { field: string; recordLabel?: RecordLabel; children?: React.ReactNode };\n        field = props.field;\n\n        paths.add(field);\n\n        if (props.recordLabel) {\n          aggregatePathsFromRecordLabel(props.recordLabel, () => getFieldsToSelectOnRecordLabelCallback?.(newCurrentPath) ?? []).forEach(\n            (path) => paths.add(`${field}.${path}`)\n          );\n        }\n      }\n\n      if (childPaths.length > 0) {\n        for (const childPath of childPaths) {\n          paths.add(field ? `${field}.${childPath}` : childPath);\n        }\n      }\n    }\n  });\n\n  return Array.from(paths);\n};\n\nconst aggregatePathsFromRecordLabel = (recordLabel: RecordLabel, getFieldsToSelectOnRecordLabelCallback: () => string[]) => {\n  const selectedPaths = new Set<string>();\n\n  getOptionLabelsFromRecordLabel(recordLabel)\n    .flatMap((optionLabel) => getSelectedPathsFromOptionLabel(optionLabel, getFieldsToSelectOnRecordLabelCallback))\n    .forEach((path) => selectedPaths.add(path));\n\n  return Array.from(selectedPaths);\n};\n\nconst falseForIdFieldsUnlessUpsertWithoutFindBy = (props: { isUpsertWithFindBy?: boolean; metadata: FieldMetadata }) => {\n  const { isUpsertWithFindBy, metadata } = props;\n  return metadata.fieldType === FieldType.Id ? !isUpsertWithFindBy : true;\n};\n\n/**\n * Removes `hasMany` fields that emerge from `hasManyThrough` fields that are not actually model fields\n */\nconst isJoinModelHasManyField = (field: FieldMetadata) =>\n  field.fieldType === FieldType.HasMany &&\n  field.configuration.__typename === \"GadgetHasManyConfig\" &&\n  field.configuration.isJoinModelHasManyField;\n\nconst validateFindBy = (params: {\n  operatesWithRecordId: boolean;\n  hasFindBy: boolean;\n  isUpsertMetaAction: boolean;\n  record?: GadgetRecord<any>;\n}) => {\n  const { operatesWithRecordId, hasFindBy, isUpsertMetaAction, record } = params;\n\n  if (hasFindBy && record) {\n    throw new Error(\"Passing both a 'findBy' and a 'record' prop to an AutoForm is invalid.\");\n  }\n\n  if (isUpsertMetaAction) {\n    return; // optional findBy value for upsert meta actions\n  }\n\n  if (record) {\n    if (operatesWithRecordId && !record.id) {\n      throw new Error(\"Passing a record to an action that operates with a record identity requires the record to have an id.\");\n    } else if (!operatesWithRecordId) {\n      throw new Error(\"Passing a record to an action that does not operate with a record identity is invalid.\");\n    }\n  } else {\n    if (operatesWithRecordId && !hasFindBy) {\n      throw new Error(\"The 'findBy' prop is required for actions that operate with a record identity.\");\n    } else if (!operatesWithRecordId && hasFindBy) {\n      throw new Error(\"The 'findBy' prop is only allowed for actions that operate with a record identity.\");\n    }\n  }\n};\n\nconst getRootFieldsFromMetadata = (metadata: ModelWithOneActionMetadata | GlobalActionMetadata | undefined | null) => {\n  return metadata && \"fields\" in metadata ? (metadata?.fields as FieldMetadata[]) ?? [] : [];\n};\n\nconst getAllRelatedModelFieldApiIdentifiers = (props: {\n  rootFieldsMetadata: FieldMetadata[];\n  path: string;\n  includeRelationshipFields?: boolean;\n}) => {\n  const { rootFieldsMetadata, path, includeRelationshipFields = false } = props;\n\n  const pathSegments = path.split(\".\");\n\n  let currentFieldsToSearch = rootFieldsMetadata;\n  for (const pathSegment of pathSegments) {\n    const currentField = currentFieldsToSearch.find((field) => field.apiIdentifier === pathSegment);\n\n    if (\n      !currentField ||\n      !isRelationshipField(currentField) ||\n      !(\"relatedModel\" in currentField.configuration) ||\n      !currentField.configuration.relatedModel\n    ) {\n      return [];\n    }\n\n    currentFieldsToSearch = currentField.configuration.relatedModel.fields;\n  }\n\n  return includeRelationshipFields\n    ? currentFieldsToSearch.map((field) => field.apiIdentifier)\n    : currentFieldsToSearch.filter((field) => !isRelationshipField(field)).map((field) => field.apiIdentifier);\n};\n"]}