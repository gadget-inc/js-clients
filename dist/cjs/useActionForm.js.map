{"version":3,"file":"useActionForm.js","sourceRoot":"","sources":["../../src/useActionForm.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ActionFunction, AnyModelManager, GadgetRecord } from \"@gadgetinc/api-client-core\";\nimport { camelize } from \"@gadgetinc/api-client-core\";\nimport { useCallback, useEffect, useRef } from \"react\";\nimport type { FieldErrors, UseFormProps, UseFormReturn } from \"react-hook-form\";\nimport { useForm } from \"react-hook-form\";\nimport { useApi } from \"./GadgetProvider.js\";\nimport { useAction } from \"./useAction.js\";\nimport { useFindBy } from \"./useFindBy.js\";\nimport { useFindOne } from \"./useFindOne.js\";\nimport type { ErrorWrapper, OptionsType } from \"./utils.js\";\nimport { get, set } from \"./utils.js\";\nimport { exec } from \"child_process\";\n\n/** Finds a given record from the backend database by either id or a `{[field: string]: value}` slug */\nconst useFindExistingRecord = (\n  modelManager: AnyModelManager,\n  findBy: string | { [key: string]: any },\n  options: { select?: Record<string, any>; pause?: boolean }\n): [{ data?: GadgetRecord<any>; fetching: boolean; error?: ErrorWrapper }, () => void] => {\n  // for simplicity, we conditionally call either the findBy or findOne hook. this violates the rules of hooks, but is a LOT simpler than mounting and pausing both hooks and massaging the results of each together. this means we don't support the same form toggling from being for a record found by id and then later a record found by some other criteria, but that's a very rare use case. you can workaround this by adding a `key` prop to the component calling `useActionForm`, and having the value change when the find method changes, which will give different instance of the component and avoid the hook order changing.\n  if (typeof findBy === \"string\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useFindOne(modelManager as any, findBy, options);\n  } else {\n    const findByKey = Object.keys(findBy)[0];\n    const findByValue = Object.values(findBy)[0];\n    const finder = (modelManager as Record<string, any>)[`findBy${camelize(findByKey)}`];\n\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return (useFindBy as any)(finder, findByValue, options);\n  }\n};\n\n/**\n * The identity of a record to build a form for\n *\n * - Pass the ID of a record as a string to look up a record by id\n * - Pass a {<fieldValue>: <value>} object to look up a record by some other field. __Note__: a `findBy` function must exist for the field you wish to find the record by.\n *\n * @example\n * // find the user record with ID=123\n * const { isReady, submit } = useActionForm(api.user.update, { record: \"123\" });\n *\n * @example\n * // find a record by email. `api.user.findByEmail` must exist\n * const { isReady, submit } = useActionForm(api.user.update, { record: { email: \"user@gadget.app\" } });\n */\nexport type RecordIdentifier = string | { [key: string]: any };\n\nexport type UseActionFormResult<\n  GivenOptions extends OptionsType,\n  SchemaT,\n  ActionFunc extends ActionFunction<GivenOptions, any, any, SchemaT, any>,\n  FormContext = any\n> = Omit<UseFormReturn<ActionFunc[\"variablesType\"], FormContext>, \"handleSubmit\"> & {\n  /**\n   * Are any request outstanding, either to fetch the initial data or to submit the action data\n   */\n  fetching: boolean;\n  /**\n   * Is the initial data currently being fetched\n   */\n  fetchingInitialData: boolean;\n  /**\n   * Is the action currently sending data\n   */\n  fetchingActionData: boolean;\n  /**\n   * Any error that occurred during initial data fetching or action submission\n   */\n  error?: ErrorWrapper | Error | null;\n  /**\n   * Function to call to submit the form\n   */\n  submit: () => Promise<void>;\n  /**\n   * Is the form ready for user input\n   */\n  isReady: boolean;\n  /**\n   * Has the submission been sent to the server successfully or not\n   */\n  submissionCompleted: boolean;\n  /**\n   * The data resulting from running the action\n   */\n  actionData?: ReturnType<typeof useAction<GivenOptions, SchemaT, ActionFunc, any>>[0][\"data\"];\n};\n\n/**\n * React hook to manage state for a form that calls a Gadget action. `useActionForm` must be passed an action function from an instance of your generated API client library, like `api.user.create`, `api.blogPost.publish` or `api.someGlobalAction`. `useActionForm` returns a `Form` object from `react-hook-form` which can be used to build great form experiences.\n *\n * `useActionForm` manages the Gadget API calls for the form, and handling validation errors returned by the Gadget backend. If your form is for an existing record, `useActionForm` will also fetch the record from the backend and populate the form with the existing values.\n *\n * `useActionForm` doesn't run the action when called. To actually submit the form, call the `submit` function on the returned `Form` object.\n *\n * @see https://react-hook-form.com/\n *\n * @param action an action function from a model manager in your application's client, like `api.user.create`\n * @param options action options, like selecting the fields in the result\n */\nexport const useActionForm = <\n  GivenOptions extends OptionsType, // currently necessary for Options to be a narrow type (e.g., `true` instead of `boolean`)\n  SchemaT,\n  ActionFunc extends ActionFunction<GivenOptions, any, any, SchemaT, any>,\n  FormContext = any\n>(\n  action: ActionFunc,\n  options?: UseFormProps<ActionFunc[\"variablesType\"], FormContext> & {\n    /**\n     * The record identifier to run this action on, if it already exists.\n     * Should be undefined for create actions, or a record ID (or finder) for update / etc actions\n     **/\n    record?: RecordIdentifier;\n    /**\n     * Which fields to select on from the record when retrieving it from the backend.\n     */\n    select?: ActionFunc[\"optionsType\"][\"select\"];\n    /**\n     * Which fields to send from the form's values when sending it from the backend.\n     */\n    send?: string[];\n    /**\n     * Called when the form submits\n     */\n    onSubmit?: () => void;\n    /**\n     * Called when the action completes successfully on the backend\n     */\n    onSuccess?: (actionResult: any) => void;\n    /**\n     * Called when the form submission errors before sending, during the API call, or if the API call returns an error.\n     */\n    onError?: (error: Error | FieldErrors<ActionFunc[\"variablesType\"]>) => void;\n  }\n): UseActionFormResult<GivenOptions, SchemaT, ActionFunc, FormContext> => {\n  const api = useApi();\n  const isForExistingRecord = !!options?.record;\n  const hasSetInitialValues = useRef<boolean>(!isForExistingRecord);\n\n  // find the existing record if there is one\n  const modelManager = (api as any)[action.modelApiIdentifier] as AnyModelManager;\n  const [findResult] = useFindExistingRecord(modelManager, options?.record || \"1\", {\n    pause: !isForExistingRecord,\n    select: options?.select,\n  });\n\n  const isReady = !isForExistingRecord || !!findResult.data;\n\n  let defaultValues = options?.defaultValues;\n  if (!defaultValues && findResult.data) {\n    defaultValues = { [action.modelApiIdentifier]: { ...findResult.data } } as any;\n  }\n\n  // setup the react-hook-form object, passing any options from the props\n  const { handleSubmit, ...formHook } = useForm<ActionFunc[\"variablesType\"], FormContext>({\n    defaultValues,\n    ...options,\n  });\n\n  // when the default values arrive from the record find later, reset them into the form. react-hook-form doesn't watch the default values after the first render\n  useEffect(() => {\n    if (isReady && !hasSetInitialValues.current && defaultValues) {\n      hasSetInitialValues.current = true;\n      formHook.reset(defaultValues);\n    }\n  }, [isReady, defaultValues, formHook]);\n\n  // get the action runner to run on submit\n  const [actionResult, runAction] = useAction(action, { select: options?.select } as any);\n\n  const handleSubmissionError = useCallback(\n    (error: Error | FieldErrors<ActionFunc[\"variablesType\"]>) => {\n      if(\"executionErrors\" in error) {\n        const executionErrors = (error as unknown as ErrorWrapper).executionErrors;\n        for (const executionError of executionErrors) {\n          if (\"validationErrors\" in executionError) {\n            for (const validationError of executionError.validationErrors) {\n              formHook.setError(`${action.modelApiIdentifier}.${validationError.apiIdentifier}` as any, { message: validationError.message });\n            }\n          } else {\n            const codeToReplace = \"code\" in executionError ? `${executionError.code}: ` : \"\";\n            const message = executionError.message.replace(codeToReplace, \"\");\n\n            formHook.setError(\"root\", { message })\n          }\n        }\n      }\n\n      options?.onError?.(error);\n    },\n    [action.modelApiIdentifier, formHook, options]\n  );\n\n  const submit = useCallback(\n    async (event?: React.BaseSyntheticEvent<object, any, any> | undefined) => {\n      let submitPromise: Promise<void> = Promise.resolve();\n\n      const innerHandleSubmit = handleSubmit(\n        (data) => {\n          let modelInput = data[action.modelApiIdentifier];\n          if (modelInput) {\n            modelInput = { ...modelInput };\n            delete modelInput.__typename;\n            delete modelInput.id;\n            delete modelInput.createdAt;\n            delete modelInput.updatedAt;\n          }\n\n          let variables: Record<string, any> = {\n            id: isForExistingRecord ? findResult.data.id : undefined,\n            ...data,\n            [action.modelApiIdentifier]: modelInput,\n          };\n\n          if (options?.send) {\n            const unmasked = variables;\n            variables = {};\n            for (const key of options.send) {\n              set(variables, key, get(unmasked, key));\n            }\n          }\n\n          options?.onSubmit?.();\n\n          submitPromise = runAction(variables as any).then((result) => {\n            if (result.error) {\n              handleSubmissionError(result.error);\n            } else {\n              options?.onSuccess?.(result.data);\n            }\n          }, handleSubmissionError);\n        },\n        (errors) => {\n          console.log(\"[gadget] error submitting form\", errors);\n          handleSubmissionError(errors);\n        }\n      );\n\n      await innerHandleSubmit(event);\n\n      await submitPromise;\n    },\n    [handleSubmit, handleSubmissionError, findResult.data, options, action.modelApiIdentifier, isForExistingRecord, runAction]\n  );\n\n  return {\n    ...formHook,\n    fetching: findResult.fetching || actionResult.fetching,\n    fetchingInitialData: findResult.fetching,\n    fetchingActionData: actionResult.fetching,\n    error: findResult.error || actionResult.error,\n    submit,\n    isReady,\n    submissionCompleted: !!actionResult.data,\n    actionData: actionResult.data,\n  };\n};\n"]}