{"version":3,"file":"GadgetFunctions.js","sourceRoot":"","sources":["../../src/GadgetFunctions.ts"],"names":[],"mappings":"","sourcesContent":["import type { GadgetRecord, RecordShape } from \"./GadgetRecord.js\";\nimport type { GadgetRecordList } from \"./GadgetRecordList.js\";\nimport type { VariableOptions } from \"./operationBuilders.js\";\nimport type { LimitToKnownKeys } from \"./types.js\";\n\nexport type AsyncRecord<T extends RecordShape> = Promise<GadgetRecord<T>>;\nexport type AsyncNullableRecord<T extends RecordShape> = Promise<GadgetRecord<T> | null>;\nexport type AsyncRecordList<T extends RecordShape> = Promise<GadgetRecordList<T>>;\n\nexport interface FindOneFunction<OptionsT, SelectionT, SchemaT, DefaultsT> {\n  <Options extends OptionsT>(fieldValue: string, options?: LimitToKnownKeys<Options, OptionsT>): AsyncRecord<any>;\n\n  type: \"findOne\";\n  findByVariableName: string;\n  operationName: string;\n  modelApiIdentifier: string;\n  defaultSelection: DefaultsT;\n  selectionType: SelectionT;\n  optionsType: OptionsT;\n  schemaType: SchemaT | null;\n}\n\nexport interface MaybeFindOneFunction<OptionsT, SelectionT, SchemaT, DefaultsT> {\n  <Options extends OptionsT>(fieldValue: string, options?: LimitToKnownKeys<Options, OptionsT>): AsyncNullableRecord<any>;\n\n  type: \"maybeFindOne\";\n  findByVariableName: string;\n  operationName: string;\n  modelApiIdentifier: string;\n  defaultSelection: DefaultsT;\n  selectionType: SelectionT;\n  optionsType: OptionsT;\n  schemaType: SchemaT | null;\n}\n\nexport interface FindManyFunction<OptionsT, SelectionT, SchemaT, DefaultsT> {\n  <Options extends OptionsT>(options?: LimitToKnownKeys<Options, OptionsT>): AsyncRecordList<any>;\n\n  type: \"findMany\";\n  operationName: string;\n  modelApiIdentifier: string;\n  defaultSelection: DefaultsT;\n  selectionType: SelectionT;\n  optionsType: OptionsT;\n  schemaType: SchemaT | null;\n}\n\nexport interface FindFirstFunction<OptionsT, SelectionT, SchemaT, DefaultsT> {\n  <Options extends OptionsT>(options?: LimitToKnownKeys<Options, OptionsT>): AsyncRecord<any>;\n\n  type: \"findFirst\";\n  operationName: string;\n  modelApiIdentifier: string;\n  defaultSelection: DefaultsT;\n  selectionType: SelectionT;\n  optionsType: OptionsT;\n  schemaType: SchemaT | null;\n}\n\nexport interface MaybeFindFirstFunction<OptionsT, SelectionT, SchemaT, DefaultsT> {\n  <Options extends OptionsT>(options?: LimitToKnownKeys<Options, OptionsT>): AsyncNullableRecord<any>;\n\n  type: \"maybeFindFirst\";\n  operationName: string;\n  modelApiIdentifier: string;\n  defaultSelection: DefaultsT;\n  selectionType: SelectionT;\n  optionsType: OptionsT;\n  schemaType: SchemaT | null;\n}\n\ninterface ActionWithIdAndVariables<OptionsT, VariablesT> {\n  <Options extends OptionsT>(id: string, variables: VariablesT, options?: LimitToKnownKeys<Options, OptionsT>):\n    | AsyncRecord<any>\n    | Promise<void>;\n}\n\ninterface ActionWithNoIdAndVariables<OptionsT, VariablesT> {\n  <Options extends OptionsT>(variables: VariablesT, options?: LimitToKnownKeys<Options, OptionsT>): AsyncRecord<any>;\n}\n\ninterface ActionWithIdAndNoVariables<OptionsT> {\n  <Options extends OptionsT>(id: string, options?: LimitToKnownKeys<Options, OptionsT>): AsyncRecord<any> | Promise<void>;\n}\n\ninterface ActionWithNoIdAndNoVariables<OptionsT> {\n  <Options extends OptionsT>(options?: LimitToKnownKeys<Options, OptionsT>): AsyncRecord<any>;\n}\n\ninterface BulkActionWithIdsAndNoVariables<OptionsT> {\n  <Options extends OptionsT>(ids: string[], options?: LimitToKnownKeys<Options, OptionsT>): AsyncRecord<any>;\n}\n\ninterface ActionFunctionMetadata<OptionsT, VariablesT, SelectionT, SchemaT, DefaultsT, IsBulk> {\n  type: \"action\";\n  operationName: string;\n  namespace: string | null;\n  modelApiIdentifier: string;\n  modelSelectionField: string;\n  defaultSelection: DefaultsT;\n  selectionType: SelectionT;\n  optionsType: OptionsT;\n  schemaType: SchemaT | null;\n  variables: VariableOptions;\n  variablesType: VariablesT;\n  isBulk: IsBulk;\n  hasAmbiguousIdentifier?: boolean;\n  hasCreateOrUpdateEffect?: boolean;\n  paramOnlyVariables?: readonly string[];\n}\n\nexport type ActionFunction<OptionsT, VariablesT, SelectionT, SchemaT, DefaultsT> = ActionFunctionMetadata<\n  OptionsT,\n  VariablesT,\n  SelectionT,\n  SchemaT,\n  DefaultsT,\n  false\n> &\n  (\n    | ActionWithIdAndVariables<OptionsT, VariablesT>\n    | ActionWithIdAndNoVariables<OptionsT>\n    | ActionWithNoIdAndVariables<OptionsT, VariablesT>\n    | ActionWithNoIdAndNoVariables<OptionsT>\n  );\n\nexport type BulkActionFunction<OptionsT, VariablesT, SelectionT, SchemaT, DefaultsT> = ActionFunctionMetadata<\n  OptionsT,\n  VariablesT,\n  SelectionT,\n  SchemaT,\n  DefaultsT,\n  true\n> &\n  BulkActionWithIdsAndNoVariables<OptionsT>;\n\nexport interface GetFunction<OptionsT, SelectionT, SchemaT, DefaultsT> {\n  <Options extends OptionsT>(options?: LimitToKnownKeys<Options, OptionsT>): AsyncRecord<GadgetRecord<any>>;\n\n  type: \"get\";\n  operationName: string;\n  modelApiIdentifier: string;\n  defaultSelection: DefaultsT;\n  selectionType: SelectionT;\n  optionsType: OptionsT;\n  schemaType: SchemaT | null;\n}\n\nexport interface GlobalActionFunction<VariablesT> {\n  (variables: VariablesT): Promise<any>;\n\n  type: \"globalAction\";\n  operationName: string;\n  namespace: string | null;\n  variables: VariableOptions;\n  variablesType: VariablesT;\n}\n"]}