{"version":3,"file":"useFetch.js","sourceRoot":"","sources":["../../src/useFetch.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Reducer } from \"react\";\nimport { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport { useConnection } from \"./GadgetProvider.js\";\nimport { useStructuralMemo } from \"./useStructuralMemo.js\";\nimport { ErrorWrapper } from \"./utils.js\";\n\nexport interface FetchHookState<T> {\n  data?: T;\n  response?: Response;\n  error?: ErrorWrapper;\n  fetching: boolean;\n  streaming: boolean;\n  options: FetchHookOptions;\n}\n\nexport type FetchHookResult<T, U = T> = [FetchHookState<T>, (opts?: Partial<FetchHookOptions>) => Promise<U>];\n\ntype FetchAction<T> =\n  | { type: \"fetching\" }\n  | { type: \"streaming\" }\n  | { type: \"fetched\"; payload: T }\n  | { type: \"streamed\" }\n  | { type: \"update\"; payload: T }\n  | { type: \"error\"; payload: ErrorWrapper };\n\nconst reducer = <T>(state: FetchHookState<T>, action: FetchAction<T>): FetchHookState<T> => {\n  switch (action.type) {\n    case \"fetching\":\n      return { ...state, fetching: true, streaming: false, error: undefined };\n    case \"streaming\":\n      return { ...state, streaming: true };\n    case \"streamed\":\n      return { ...state, streaming: false };\n    case \"fetched\":\n      return { ...state, fetching: false, data: action.payload, error: undefined };\n    case \"update\":\n      return { ...state, data: action.payload };\n    case \"error\":\n      return { ...state, fetching: false, error: action.payload };\n    default:\n      return state;\n  }\n};\n\nexport interface FetchHookOptions extends RequestInit {\n  stream?: boolean | string;\n  json?: boolean;\n  sendImmediately?: boolean;\n  onStreamComplete?: (value: string) => void;\n}\n\nconst startRequestByDefault = (options?: FetchHookOptions) => {\n  if (typeof options?.sendImmediately != \"undefined\") {\n    return options.sendImmediately;\n  } else {\n    return !options?.method || options.method === \"GET\";\n  }\n};\n\nconst dispatchError = (\n  mounted: React.MutableRefObject<boolean>,\n  dispatch: React.Dispatch<FetchAction<any>>,\n  error: any,\n  response?: Response\n) => {\n  if (!mounted.current) return null;\n\n  const wrapped = ErrorWrapper.forClientSideError(error, response);\n  dispatch({ type: \"error\", payload: wrapped });\n\n  return wrapped;\n};\n\n/**\n * React hook to make an HTTP request to a Gadget backend HTTP route. Preserves client side session information and ensures it's passed along to the backend.\n *\n * Returns a tuple with the current state of the request and a function to send or re-send the request. The state is an object with the following fields:\n * - `data`: the response data, if the request was successful\n * - `fetching`: a boolean describing if the fetch request is currently in progress\n * - `streaming`: a boolean describing if the fetch request is currently streaming. This is only set when the option `{ stream: \"string\" }` is passed\n * - `error`: an error object if the request failed in any way\n *\n * The second return value is a function for executing the fetch request. It returns a promise for the response body.\n *\n * By default, `GET` requests are sent as soon as the hook executes. Any other request methods are not sent automatically, and must be triggered by calling the `execute` function returned in the second argument.\n *\n * Pass the `{ json: true }` option to expect a JSON response from the server, and to automatically parse the response as JSON. Otherwise, the response will be returned as a `string` object.\n *\n * Pass the `{ stream: true }` to get a `ReadableStream` object as a response from the server, allowing you to work with the response as it arrives.\n *\n * Pass the `{ stream: \"string\" }` to decode the `ReadableStream` as a string and update data as it arrives. If the stream is in an encoding other than utf8 use i.e. `{ stream: \"utf-16\" }`.\n *\n * When `{ stream: \"string\" }` is used, the `streaming` field in the state will be set to `true` while the stream is active, and `false` when the stream is complete. You can use this to show a loading indicator while the stream is active.\n * You can also pass an `onStreamComplete` callback that will be called with the value of the streamed string once it has completed.\n *\n * If you want to read model data, see the `useFindMany` function and similar. If you want to invoke a backend Action, use the `useAction` hook instead.\n *\n * @param path the backend path to fetch\n * @param options the `fetch` options for the request\n *\n * @example\n * ```\n * export function UserByEmail(props: { email: string }) {\n *   const [{data, fetching, error}, refresh] = useFetch(\"/users/get\", {\n *     method: \"GET\",\n *     body: JSON.stringify({ email: props.email }})\n *     headers: {\n *       \"content-type\": \"application/json\",\n *     }\n *     json: true,\n *   });\n *\n *   if (result.error) return <>Error: {result.error.toString()}</>;\n *   if (result.fetching && !result.data) return <>Fetching...</>;\n *   if (!result.data) return <>No user found with id={props.id}</>;\n *\n *   return <div>{result.data.name}</div>;\n * }\n */\nexport function useFetch(path: string, options: { stream: string } & FetchHookOptions): FetchHookResult<string, ReadableStream<string>>;\nexport function useFetch(path: string, options: { stream: true } & FetchHookOptions): FetchHookResult<ReadableStream<Uint8Array>>;\nexport function useFetch<T extends Record<string, any>>(url: string, options: { json: true } & FetchHookOptions): FetchHookResult<T>;\nexport function useFetch(path: string, options?: FetchHookOptions): FetchHookResult<string>;\nexport function useFetch<T = string>(path: string, options?: FetchHookOptions): FetchHookResult<T> {\n  // Used to prevent state update if the component is unmounted\n  const mounted = useRef<boolean>(true);\n  const { onStreamComplete, ...optionsToMemoize } = options ?? {};\n  const memoizedOptions = useStructuralMemo<FetchHookOptions>(optionsToMemoize);\n  const connection = useConnection();\n  const startRequestOnMount = startRequestByDefault(memoizedOptions);\n  const controller = useRef<AbortController | null>(null);\n\n  const [state, dispatch] = useReducer<Reducer<FetchHookState<T>, FetchAction<T>>, FetchHookOptions>(\n    reducer,\n    memoizedOptions,\n    (memoizedOptions) => {\n      return { fetching: startRequestOnMount, streaming: false, options: memoizedOptions };\n    }\n  );\n\n  const send = useCallback(\n    async (sendOptions?: Partial<FetchHookOptions>): Promise<T> => {\n      controller.current?.abort(\"useFetch is starting a new request, aborting the previous one\");\n      const abortContoller = new AbortController();\n      controller.current = abortContoller;\n\n      dispatch({ type: \"fetching\" });\n\n      let data: any;\n      let response: Response | undefined = undefined;\n\n      const mergedOptions = { ...memoizedOptions, onStreamComplete, ...sendOptions };\n\n      // add implicit headers from options, being careful not to mutate any inputs\n      if (mergedOptions.json) {\n        mergedOptions.headers = { ...mergedOptions.headers };\n        (mergedOptions.headers as any)[\"accept\"] ??= \"application/json\";\n      }\n\n      try {\n        const { json: _json, stream: _stream, onStreamComplete: _onStreamComplete, ...fetchOptions } = mergedOptions;\n        // make the fetch call using GadgetConnection to pass along auth and other headers\n        response = await connection.fetch(path, { signal: abortContoller.signal, ...fetchOptions });\n        if (!response.ok) {\n          throw new Error(response.statusText);\n        }\n\n        let dispatchData = true;\n\n        if (mergedOptions.json) {\n          data = await response.json();\n        } else if (typeof mergedOptions.stream === \"string\") {\n          dispatchData = false;\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const decodedStream = response.body!.pipeThrough(\n            new TextDecoderStream(mergedOptions.stream === \"string\" ? \"utf8\" : mergedOptions.stream)\n          );\n\n          const [responseStream, updateStream] = decodedStream.tee();\n\n          data = responseStream;\n          const decodedStreamReader = updateStream.getReader();\n\n          decodedStreamReader.closed.catch((error) => {\n            if (!abortContoller.signal.aborted) {\n              dispatchError(mounted, dispatch, error, response);\n            }\n          });\n\n          dispatch({ type: \"fetched\", payload: \"\" as any });\n\n          (async () => {\n            let responseText = \"\";\n            let done = false;\n\n            dispatch({ type: \"streaming\" });\n\n            while (!done) {\n              const { value, done: _done } = await decodedStreamReader.read();\n              done = _done;\n\n              if (value) {\n                responseText += value;\n\n                if (!abortContoller.signal.aborted) {\n                  dispatch({ type: \"update\", payload: responseText as any });\n                }\n              }\n            }\n\n            mergedOptions.onStreamComplete?.(responseText);\n          })()\n            .catch((error) => {\n              if (!abortContoller.signal.aborted) {\n                dispatchError(mounted, dispatch, error, response);\n              }\n            })\n            .finally(() => {\n              dispatch({ type: \"streamed\" });\n            });\n        } else if (mergedOptions.stream) {\n          data = response.body;\n        } else {\n          data = await response.text();\n        }\n\n        if (!mounted.current || !dispatchData) return data;\n\n        dispatch({ type: \"fetched\", payload: data });\n      } catch (error: any) {\n        const wrapped = dispatchError(mounted, dispatch, error, response);\n        if (!wrapped) return null as any;\n        throw wrapped;\n      }\n      return data;\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [connection, memoizedOptions, path]\n  );\n\n  // track if we're mounted or not\n  useEffect(() => {\n    mounted.current = true;\n\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n\n  // execute the initial request on mount if needed\n  useEffect(() => {\n    if (startRequestOnMount) {\n      void send().catch(() => {\n        // error will be reported via the return value of the hook\n      });\n    }\n\n    // abort if the component is unmounted, or if one of the key elements of the request changes such that we don't want an outstanding request's result anymore\n    return () => {\n      controller.current?.abort();\n    };\n  }, [path, startRequestOnMount, send]);\n\n  return [state, send];\n}\n"]}