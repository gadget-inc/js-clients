{"version":3,"file":"liveQueryExchange.js","sourceRoot":"","sources":["../../../src/exchanges/liveQueryExchange.ts"],"names":[],"mappings":";;;AACA,iCAAiD;AACjD,gEAA4E;AAE5E;;;;GAIG;AACI,MAAM,iBAAiB,GAAa,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE;IACzD,MAAM,QAAQ,GAAG,IAAI,GAAG,EAAU,CAAC;IAEnC,MAAM,cAAc,GAAG,CAAC,EAAuB,EAAE,EAAE;QACjD,OAAO,EAAE,CAAC,GAAG,CAAC;IAChB,CAAC,CAAC;IAEF,OAAO,CAAC,WAAW,EAAE,EAAE;QACrB,MAAM,OAAO,GAAG,IAAA,YAAI,EAClB,WAAW,EACX,IAAA,cAAM,EAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,wDAAkC,CAAC,CAAC,CAC/E,CAAC;QAEF,MAAM,IAAI,GAAG,IAAA,YAAI,EACf,WAAW,EACX,IAAA,cAAM,EAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,wDAAkC,CAAC,CAAC,EAC7E,IAAA,cAAM,EAAC,CAAC,EAAE,EAAE,EAAE;YACZ,MAAM,IAAI,GAAG,cAAc,CAAC,EAAE,CAAC,CAAC;YAChC,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,IAAI,KAAK,OAAO,CAAC;QACpD,CAAC,CAAC,EACF,IAAA,WAAG,EAAC,CAAC,EAAE,EAAE,EAAE;YACT,MAAM,IAAI,GAAG,cAAc,CAAC,EAAE,CAAC,CAAC;YAChC,IAAI,EAAE,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;gBACxB,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACrB,CAAC;iBAAM,IAAI,EAAE,CAAC,IAAI,KAAK,UAAU,EAAE,CAAC;gBAClC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YACxB,CAAC;QACH,CAAC,CAAC,CACH,CAAC;QAEF,OAAO,OAAO,CAAC,IAAA,aAAK,EAAC,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;IACzC,CAAC,CAAC;AACJ,CAAC,CAAC;AAhCW,QAAA,iBAAiB,qBAgC5B","sourcesContent":["import type { Exchange, Operation } from \"@urql/core\";\nimport { filter, merge, pipe, tap } from \"wonka\";\nimport { isLiveQueryOperationDefinitionNode } from \"../GadgetConnection.js\";\n\n/**\n * Exchange that prevents duplicate execution of live queries while allowing proper teardown and re-establishment.\n *\n * Live queries are long-running special subscriptions that receive real-time updates from the server. When mutations occur, urql's cache exchange tries to re-execute any mounted queries that could be affected and so re-executes live queries. Live queries automatically update their own data using their own persistent connection, so they shouldn't be re-executed if already mounted.\n */\nexport const liveQueryExchange: Exchange = ({ forward }) => {\n  const executed = new Set<number>();\n\n  const getOperationId = (op: Operation<any, any>) => {\n    return op.key;\n  };\n\n  return (operations$) => {\n    const notLive = pipe(\n      operations$,\n      filter((op) => !op.query.definitions.some(isLiveQueryOperationDefinitionNode))\n    );\n\n    const live = pipe(\n      operations$,\n      filter((op) => op.query.definitions.some(isLiveQueryOperationDefinitionNode)),\n      filter((op) => {\n        const opId = getOperationId(op);\n        return !executed.has(opId) || op.kind !== \"query\";\n      }),\n      tap((op) => {\n        const opId = getOperationId(op);\n        if (op.kind === \"query\") {\n          executed.add(opId);\n        } else if (op.kind === \"teardown\") {\n          executed.delete(opId);\n        }\n      })\n    );\n\n    return forward(merge([live, notLive]));\n  };\n};\n"]}