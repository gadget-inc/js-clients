{"version":3,"file":"GadgetTransaction.js","sourceRoot":"","sources":["../../src/GadgetTransaction.ts"],"names":[],"mappings":";;;AAEA,6CAAsD;AAEtD,oHAAoH;AACpH,MAAa,qBAAsB,SAAQ,KAAK;CAAG;AAAnD,sDAAmD;AAEnD,4DAA4D;AAC5D,MAAa,iBAAiB;IAE5B,YAAqB,MAAc,EAAW,kBAAsC;QAAxE;;;;mBAAS,MAAM;WAAQ;QAAE;;;;mBAAS,kBAAkB;WAAoB;QADpF;;;;mBAAO,KAAK;WAAC;IAC0E,CAAC;IAExF,2EAA2E;IAC3E,KAAK;QACH,IAAI,IAAI,CAAC,IAAI,EAAE;YACb,KAAK,IAAI,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC;SACxC;QACD,KAAK,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,CAAC;IACzC,CAAC;IAED,gHAAgH;IAChH,KAAK,CAAC,QAAQ;QACZ,IAAA,mCAAsB,EAAC,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,kEAAkE,EAAE,EAAE,CAAC,CAAC,SAAS,EAAE,EAAE;YACrI,UAAU;YACV,qBAAqB;SACtB,CAAC,CAAC;QACH,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;QAClB,MAAM,IAAI,qBAAqB,CAAC,0BAA0B,CAAC,CAAC;IAC9D,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,KAAK;QACT,IAAA,mCAAsB,EAAC,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,4DAA4D,EAAE,EAAE,CAAC,CAAC,SAAS,EAAE,EAAE;YAC/H,UAAU;YACV,kBAAkB;SACnB,CAAC,CAAC;QACH,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IACnB,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,MAAM;QACV,IAAA,mCAAsB,EAAC,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,8DAA8D,EAAE,EAAE,CAAC,CAAC,SAAS,EAAE,EAAE;YACjI,UAAU;YACV,mBAAmB;SACpB,CAAC,CAAC;QACH,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;IACpB,CAAC;CACF;AA3CD,8CA2CC","sourcesContent":["import type { Client } from \"@urql/core\";\nimport type { Client as SubscriptionClient } from \"graphql-ws\";\nimport { assertOperationSuccess } from \"./support.js\";\n\n/** Represents the error thrown when a transaction is explicity rolled back, sometimes due to another inner error */\nexport class TransactionRolledBack extends Error {}\n\n/** Represents an open transaction against the Gadget API */\nexport class GadgetTransaction {\n  open = false;\n  constructor(readonly client: Client, readonly subscriptionClient: SubscriptionClient) {}\n\n  /** Shut down this transaction by closing the connection to the backend. */\n  close() {\n    if (this.open) {\n      void this.rollback().catch(() => null);\n    }\n    void this.subscriptionClient.dispose();\n  }\n\n  /** Explicitly roll back this transaction, preventing any of the changes made during it from being committed. */\n  async rollback() {\n    assertOperationSuccess(await this.client.mutation(`mutation RollbackTransaction { internal { rollbackTransaction }}`, {}).toPromise(), [\n      \"internal\",\n      \"rollbackTransaction\",\n    ]);\n    this.open = false;\n    throw new TransactionRolledBack(\"Transaction rolled back.\");\n  }\n\n  /**\n   * @private\n   */\n  async start() {\n    assertOperationSuccess(await this.client.mutation(`mutation StartTransaction { internal { startTransaction }}`, {}).toPromise(), [\n      \"internal\",\n      \"startTransaction\",\n    ]);\n    this.open = true;\n  }\n\n  /**\n   * @private\n   */\n  async commit() {\n    assertOperationSuccess(await this.client.mutation(`mutation CommitTransaction { internal { commitTransaction }}`, {}).toPromise(), [\n      \"internal\",\n      \"commitTransaction\",\n    ]);\n    this.open = false;\n  }\n}\n"]}