{"version":3,"file":"metadata.js","sourceRoot":"","sources":["../../src/metadata.tsx"],"names":[],"mappings":";;;AACA,gEAAoD;AAEpD,2DAA6C;AAC7C,kDAAgD;AAChD,0DAA4D;AAC5D,2DAAqD;AACrD,yCAA2D;AAE3D;;;GAGG;AACU,QAAA,SAAS,GAAG,4BAAe,CAAC;AAKzC,MAAM,qBAAqB,GAAG,IAAA,gBAAO,EAAC,aAAa,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmEnD,CAAC,CAAC;AAEH,MAAM,kBAAkB,GAAG,IAAA,gBAAO,EAAC,aAAa,CAAC;;;;;;;;;;;;;CAahD,CAAC,CAAC;AAEH,MAAM,kBAAkB,GAAG,IAAA,gBAAO,EAAC,aAAa,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8BhD,CAAC,CAAC;AAEH,MAAM,wBAAwB,GAAG,IAAA,gBAAO,EAAC,aAAa,CAAC;;;;;;;;;;;;;;;;;CAiBtD,CAAC,CAAC;AAEH,MAAM,kBAAkB,GAAG,IAAA,gBAAO,EAAC,aAAa,CAAC;;;;;;;;;;CAUhD,CAAC,CAAC;AASH;;;GAGG;AACI,MAAM,gBAAgB,GAAG,CAAC,aAAqB,EAAE,SAAmB,EAAE,EAAE;IAC7E,MAAM,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC,GAAG,IAAA,kCAAc,EAAC;QACjD,KAAK,EAAE,kBAAkB;QACzB,SAAS,EAAE,EAAE,aAAa,EAAE,SAAS,EAAE;KACxC,CAAC,CAAC;IAEH,OAAO;QACL,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC,IAAA,wBAAM,EAAC,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,yCAAyC,CAAC,CAAC,CAAC,CAAC,IAAI;QAChG,QAAQ;QACR,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,uBAAY,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS;KAClE,CAAC;AACJ,CAAC,CAAC;AAXW,QAAA,gBAAgB,oBAW3B;AAEF;;;GAGG;AACI,MAAM,iBAAiB,GAAG,CAAC,cAAuD,EAAE,EAAE;IAC3F,MAAM,GAAG,GAAG,IAAA,0BAAM,GAAE,CAAC;IACrB,MAAM,YAAY,GAAG,IAAA,wBAAM,EACzB,IAAA,0BAAe,EAAC,GAAG,EAAE,cAAc,CAAC,kBAAkB,EAAE,cAAc,CAAC,SAAS,CAAC,EACjF,4CAA4C,CAC7C,CAAC;IACF,IAAI,UAAU,CAAC;IACf,MAAM,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;IAClD,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;QACjD,IAAI,KAAK,KAAK,cAAc,EAAE,CAAC;YAC7B,UAAU,GAAG,GAAG,CAAC;YACjB,MAAM;QACR,CAAC;IACH,CAAC;IACD,IAAI,CAAC,UAAU,EAAE,CAAC;QAChB,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;IAChE,CAAC;IAED,MAAM,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC,GAAG,IAAA,kCAAc,EAAC;QACjD,KAAK,EAAE,wBAAwB;QAC/B,SAAS,EAAE;YACT,kBAAkB,EAAE,cAAc,CAAC,kBAAkB;YACrD,cAAc,EAAE,cAAc,CAAC,SAAS;YACxC,MAAM,EAAE,UAAU;SACnB;KACF,CAAC,CAAC;IAEH,IAAI,IAAI,EAAE,CAAC;QACT,IAAA,wBAAM,EAAC,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,MAAM,EAAE,yCAAyC,CAAC,CAAC;IACnF,CAAC;IAED,OAAO;QACL,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,UAAU,CAAC,KAAwB,CAAC,CAAC,CAAC,IAAI;QACjE,QAAQ;QACR,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,uBAAY,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS;KAClE,CAAC;AACJ,CAAC,CAAC;AApCW,QAAA,iBAAiB,qBAoC5B;AAEF;;GAEG;AACI,MAAM,eAAe,GAAG,CAC7B,MAAmC,EACnC,OAAoD,EACnC,EAAE;IACnB,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,IAAI,MAAM,GAAG,MAAM,CAAC;IAEpB,IAAI,OAAO,EAAE,OAAO,EAAE,CAAC;QACrB,+EAA+E;QAC/E,MAAM,GAAG,EAAE,CAAC;QACZ,MAAM,QAAQ,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QAE1C,KAAK,MAAM,kBAAkB,IAAI,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;YACtD,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,aAAa,KAAK,kBAAkB,CAAC,CAAC;YACzF,IAAI,aAAa,EAAE,CAAC;gBAClB,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YAC7B,CAAC;QACH,CAAC;IACH,CAAC;IAED,IAAI,OAAO,EAAE,OAAO,EAAE,CAAC;QACrB,MAAM,QAAQ,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QAC1C,IAAI,OAAO,EAAE,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC;YACvF,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC;QAC/D,CAAC;QAED,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC;IACxE,CAAC;IAED,uDAAuD;IACvD,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,kBAAkB,CAAC,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC;AAC3E,CAAC,CAAC;AAlCW,QAAA,eAAe,mBAkC1B;AAEF,MAAM,kBAAkB,GAAG,IAAI,GAAG,CAAC;IACjC,iBAAS,CAAC,OAAO;IACjB,iBAAS,CAAC,KAAK;IACf,iBAAS,CAAC,QAAQ,EAAE,2BAA2B;IAC/C,iBAAS,CAAC,QAAQ;IAClB,iBAAS,CAAC,KAAK;IACf,iBAAS,CAAC,eAAe;IACzB,iBAAS,CAAC,IAAI;IACd,iBAAS,CAAC,IAAI;IACd,iBAAS,CAAC,IAAI;IACd,iBAAS,CAAC,MAAM;IAChB,iBAAS,CAAC,QAAQ;IAClB,iBAAS,CAAC,QAAQ;IAClB,iBAAS,CAAC,eAAe;IACzB,iBAAS,CAAC,MAAM;IAChB,iBAAS,CAAC,GAAG;IACb,iBAAS,CAAC,MAAM,EAAE,2BAA2B;IAE7C,gBAAgB;IAChB,iBAAS,CAAC,SAAS;IACnB,iBAAS,CAAC,OAAO;IACjB,iBAAS,CAAC,MAAM;CACjB,CAAC,CAAC;AAEH;;;GAGG;AACI,MAAM,gBAAgB,GAAG,GAAG,EAAE;IACnC,MAAM,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC,GAAG,IAAA,kCAAc,EAAC;QACjD,KAAK,EAAE,kBAAkB;KAC1B,CAAC,CAAC;IAEH,OAAO;QACL,KAAK,EAAE,IAAI,EAAE,UAAU,CAAC,KAAK;QAC7B,QAAQ;QACR,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,uBAAY,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS;KAClE,CAAC;AACJ,CAAC,CAAC;AAVW,QAAA,gBAAgB,oBAU3B","sourcesContent":["import type { ActionFunction } from \"@gadgetinc/api-client-core\";\nimport { assert } from \"@gadgetinc/api-client-core\";\nimport type { ResultOf } from \"@graphql-typed-document-node/core\";\nimport { useApi } from \"./GadgetProvider.js\";\nimport { graphql } from \"./internal/gql/gql.js\";\nimport { GadgetFieldType } from \"./internal/gql/graphql.js\";\nimport { useGadgetQuery } from \"./useGadgetQuery.js\";\nimport { ErrorWrapper, getModelManager } from \"./utils.js\";\n\n/**\n * The enum of all possible field types in Gadget's type system\n * @internal\n */\nexport const FieldType = GadgetFieldType;\n\ntype WithRequired<T, K extends keyof T> = T & { [P in K]-?: Exclude<T[P], null> };\ntype Clarify<T> = T extends Record<string, unknown> ? { [Key in keyof T]: T[Key] } : T;\n\nconst FieldMetadataFragment = graphql(/* GraphQL */ `\n  fragment FieldMetadata on GadgetField {\n    name\n    apiIdentifier\n    fieldType\n    requiredArgumentForInput\n    ... on GadgetModelField {\n      sortable\n      filterable\n    }\n    configuration {\n      __typename\n      fieldType\n      validations {\n        __typename\n        ... on GadgetRegexFieldValidation {\n          name\n          specID\n          pattern\n        }\n        ... on GadgetRangeFieldValidation {\n          name\n          specID\n          min\n          max\n        }\n        ... on GadgetOnlyImageFileFieldValidation {\n          name\n          specID\n          allowAnimatedImages\n        }\n        ... on GadgetGenericFieldValidation {\n          name\n          specID\n        }\n      }\n      ... on GadgetHasManyConfig {\n        relatedModel {\n          apiIdentifier\n          namespace\n        }\n      }\n      ... on GadgetHasOneConfig {\n        relatedModel {\n          apiIdentifier\n          namespace\n        }\n      }\n      ... on GadgetBelongsToConfig {\n        relatedModel {\n          apiIdentifier\n          namespace\n        }\n      }\n      ... on GadgetEnumConfig {\n        allowMultiple\n        allowOther\n        options {\n          name\n          color\n        }\n      }\n      ... on GadgetDateTimeConfig {\n        includeTime\n      }\n    }\n  }\n`);\n\nconst ModelMetadataQuery = graphql(/* GraphQL */ `\n  query GetModelMetadata($apiIdentifier: String!, $namespace: [String!]) {\n    gadgetMeta {\n      model(apiIdentifier: $apiIdentifier, namespace: $namespace) {\n        apiIdentifier\n        namespace\n        name\n        fields {\n          ...FieldMetadata\n        }\n      }\n    }\n  }\n`);\n\nconst _SubFieldsFragment = graphql(/* GraphQL */ `\n  fragment SubFields on GadgetField {\n    configuration {\n      __typename\n      ... on GadgetObjectFieldConfig {\n        name\n        fields {\n          ...FieldMetadata\n          configuration {\n            __typename\n            ... on GadgetObjectFieldConfig {\n              name\n              fields {\n                ...FieldMetadata\n                configuration {\n                  __typename\n                  ... on GadgetObjectFieldConfig {\n                    name\n                    fields {\n                      ...FieldMetadata\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n`);\n\nconst ModelActionMetadataQuery = graphql(/* GraphQL */ `\n  query ModelActionMetadata($modelApiIdentifier: String!, $modelNamespace: [String!], $action: String!) {\n    gadgetMeta {\n      model(apiIdentifier: $modelApiIdentifier, namespace: $modelNamespace) {\n        name\n        action(apiIdentifier: $action) {\n          name\n          apiIdentifier\n          operatesWithRecordIdentity\n          inputFields {\n            ...FieldMetadata\n            ...SubFields\n          }\n        }\n      }\n    }\n  }\n`);\n\nconst RolesMetadataQuery = graphql(/* GraphQL */ `\n  query RolesMetadata {\n    gadgetMeta {\n      roles {\n        name\n        key\n        selectable\n      }\n    }\n  }\n`);\n\nexport type ModelMetadata = Exclude<ResultOf<typeof ModelMetadataQuery>[\"gadgetMeta\"][\"model\"], null | undefined>;\nexport type ActionMetadata = Clarify<\n  WithRequired<Exclude<ResultOf<typeof ModelActionMetadataQuery>[\"gadgetMeta\"][\"model\"], null | undefined>, \"action\">\n>;\n\nexport type FieldMetadata = ResultOf<typeof FieldMetadataFragment>;\n\n/**\n * Retrieve a given Gadget model's metadata from the backend\n * @internal\n */\nexport const useModelMetadata = (apiIdentifier: string, namespace: string[]) => {\n  const [{ data, fetching, error }] = useGadgetQuery({\n    query: ModelMetadataQuery,\n    variables: { apiIdentifier, namespace },\n  });\n\n  return {\n    metadata: data ? assert(data.gadgetMeta.model, \"no model metadata found from Gadget API\") : data,\n    fetching,\n    error: error ? ErrorWrapper.forClientSideError(error) : undefined,\n  };\n};\n\n/**\n * Retrieve a given Gadget model's metadata from the backend\n * @internal\n */\nexport const useActionMetadata = (actionFunction: ActionFunction<any, any, any, any, any>) => {\n  const api = useApi();\n  const modelManager = assert(\n    getModelManager(api, actionFunction.modelApiIdentifier, actionFunction.namespace),\n    \"no model manager found for action function\"\n  );\n  let actionName;\n  const proto = Object.getPrototypeOf(modelManager);\n  for (const [key, value] of Object.entries(proto)) {\n    if (value === actionFunction) {\n      actionName = key;\n      break;\n    }\n  }\n  if (!actionName) {\n    throw new Error(\"action function not found on model manager\");\n  }\n\n  const [{ data, fetching, error }] = useGadgetQuery({\n    query: ModelActionMetadataQuery,\n    variables: {\n      modelApiIdentifier: actionFunction.modelApiIdentifier,\n      modelNamespace: actionFunction.namespace,\n      action: actionName,\n    },\n  });\n\n  if (data) {\n    assert(data.gadgetMeta.model?.action, \"no model metadata found from Gadget API\");\n  }\n\n  return {\n    metadata: data ? (data.gadgetMeta.model as ActionMetadata) : data,\n    fetching,\n    error: error ? ErrorWrapper.forClientSideError(error) : undefined,\n  };\n};\n\n/**\n * @internal\n */\nexport const filterFieldList = (\n  fields: FieldMetadata[] | undefined,\n  options?: { include?: string[]; exclude?: string[] }\n): FieldMetadata[] => {\n  if (!fields) {\n    return [];\n  }\n\n  let subset = fields;\n\n  if (options?.include) {\n    // When including fields, the order will match the order of the `include` array\n    subset = [];\n    const includes = new Set(options.include);\n\n    for (const includedFieldApiId of Array.from(includes)) {\n      const metadataField = fields.find((field) => field.apiIdentifier === includedFieldApiId);\n      if (metadataField) {\n        subset.push(metadataField);\n      }\n    }\n  }\n\n  if (options?.exclude) {\n    const excludes = new Set(options.exclude);\n    if (options?.include && options.include.some((fieldApiId) => excludes.has(fieldApiId))) {\n      throw new Error(\"Cannot include and exclude the same field\");\n    }\n\n    subset = subset.filter((field) => !excludes.has(field.apiIdentifier));\n  }\n\n  // Filter out fields that are not supported by the form\n  return subset.filter((field) => acceptedFieldTypes.has(field.fieldType));\n};\n\nconst acceptedFieldTypes = new Set([\n  FieldType.Boolean,\n  FieldType.Color,\n  FieldType.Computed, // Not rendered as an input\n  FieldType.DateTime,\n  FieldType.Email,\n  FieldType.EncryptedString,\n  FieldType.Enum,\n  FieldType.File,\n  FieldType.Json,\n  FieldType.Number,\n  FieldType.Password,\n  FieldType.RichText,\n  FieldType.RoleAssignments,\n  FieldType.String,\n  FieldType.Url,\n  FieldType.Vector, // Not rendered as an input\n\n  // Relationships\n  FieldType.BelongsTo,\n  FieldType.HasMany,\n  FieldType.HasOne,\n]);\n\n/**\n * Retrieve the roles available in the Gadget app from the backend\n * @internal\n */\nexport const useRolesMetadata = () => {\n  const [{ data, fetching, error }] = useGadgetQuery({\n    query: RolesMetadataQuery,\n  });\n\n  return {\n    roles: data?.gadgetMeta.roles,\n    fetching,\n    error: error ? ErrorWrapper.forClientSideError(error) : undefined,\n  };\n};\n"]}