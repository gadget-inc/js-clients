{"version":3,"file":"metadata.js","sourceRoot":"","sources":["../../src/metadata.tsx"],"names":[],"mappings":"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","sourcesContent":["import type { ActionFunction, AnyClient, GlobalActionFunction } from \"@gadgetinc/api-client-core\";\nimport { assert } from \"@gadgetinc/api-client-core\";\nimport type { ResultOf } from \"@graphql-typed-document-node/core\";\nimport type { DocumentNode } from \"graphql\";\nimport { useApi } from \"./GadgetProvider.js\";\nimport { graphql } from \"./internal/gql/gql.js\";\nimport { GadgetFieldType, type FieldMetadataFragment as FieldMetadataFragmentType } from \"./internal/gql/graphql.js\";\nimport { useGadgetQuery } from \"./useGadgetQuery.js\";\nimport { ErrorWrapper, getModelManager } from \"./utils.js\";\n\n/**\n * The enum of all possible field types in Gadget's type system\n * @internal\n */\nexport const FieldType = GadgetFieldType;\n\ntype WithRequired<T, K extends keyof T> = T & { [P in K]-?: Exclude<T[P], null> };\ntype Clarify<T> = T extends Record<string, unknown> ? { [Key in keyof T]: T[Key] } : T;\n\nconst _FieldMetadataFragment = graphql(/* GraphQL */ `\n  fragment FieldMetadata on GadgetField {\n    name\n    apiIdentifier\n    fieldType\n    requiredArgumentForInput\n    ... on GadgetModelField {\n      sortable\n      filterable\n    }\n    configuration {\n      __typename\n      fieldType\n      validations {\n        __typename\n        ... on GadgetRegexFieldValidation {\n          name\n          specID\n          pattern\n        }\n        ... on GadgetRangeFieldValidation {\n          name\n          specID\n          min\n          max\n        }\n        ... on GadgetOnlyImageFileFieldValidation {\n          name\n          specID\n          allowAnimatedImages\n        }\n        ... on GadgetGenericFieldValidation {\n          name\n          specID\n        }\n      }\n      ... on GadgetHasManyThroughConfig {\n        relatedModel {\n          key\n          name\n          apiIdentifier\n          namespace\n        }\n        inverseField {\n          apiIdentifier\n        }\n        joinModel {\n          key\n          apiIdentifier\n          namespace\n        }\n        inverseJoinModelField {\n          apiIdentifier\n        }\n        inverseRelatedModelField {\n          apiIdentifier\n        }\n      }\n      ... on GadgetHasManyConfig {\n        isJoinModelHasManyField\n        relatedModel {\n          key\n          name\n          apiIdentifier\n          namespace\n        }\n        inverseField {\n          apiIdentifier\n        }\n      }\n      ... on GadgetHasOneConfig {\n        relatedModel {\n          key\n          name\n          apiIdentifier\n          namespace\n        }\n        inverseField {\n          apiIdentifier\n        }\n      }\n      ... on GadgetBelongsToConfig {\n        relatedModel {\n          key\n          name\n          apiIdentifier\n          namespace\n        }\n      }\n      ... on GadgetEnumConfig {\n        allowMultiple\n        allowOther\n        options {\n          name\n          color\n        }\n      }\n      ... on GadgetDateTimeConfig {\n        includeTime\n      }\n      ... on GadgetNumberConfig {\n        decimals\n      }\n    }\n  }\n`);\n\nconst ModelMetadataQuery = graphql(/* GraphQL */ `\n  query GetModelMetadata($apiIdentifier: String!, $namespace: [String!]) {\n    gadgetMeta {\n      modelAndRelatedModels(apiIdentifier: $apiIdentifier, namespace: $namespace) {\n        key\n        apiIdentifier\n        namespace\n        name\n        fields {\n          ...FieldMetadata\n        }\n        defaultDisplayField {\n          name\n          apiIdentifier\n          fieldType\n        }\n      }\n    }\n  }\n`);\n\nconst _SubFieldsFragment = graphql(/* GraphQL */ `\n  fragment SubFields on GadgetField {\n    configuration {\n      __typename\n      ... on GadgetObjectFieldConfig {\n        name\n        fields {\n          ...FieldMetadata\n          configuration {\n            __typename\n            ... on GadgetObjectFieldConfig {\n              name\n              fields {\n                ...FieldMetadata\n                configuration {\n                  __typename\n                  ... on GadgetObjectFieldConfig {\n                    name\n                    fields {\n                      ...FieldMetadata\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n`);\n\nconst ModelActionMetadataQuery = graphql(/* GraphQL */ `\n  query ModelActionMetadata($modelApiIdentifier: String!, $modelNamespace: [String!], $action: String!) {\n    gadgetMeta {\n      modelAndRelatedModels(apiIdentifier: $modelApiIdentifier, namespace: $modelNamespace) {\n        key\n        name\n        namespace\n        apiIdentifier\n        defaultRecord\n        fields {\n          ...FieldMetadata\n          ...SubFields\n        }\n        defaultDisplayField {\n          name\n          apiIdentifier\n          fieldType\n        }\n      }\n      model(apiIdentifier: $modelApiIdentifier, namespace: $modelNamespace) {\n        key\n        name\n        namespace\n        apiIdentifier\n        defaultRecord\n        action(apiIdentifier: $action) {\n          name\n          apiIdentifier\n          operatesWithRecordIdentity\n          isDeleteAction\n          inputFields {\n            ...FieldMetadata\n            ...SubFields\n          }\n          triggers {\n            specID\n          }\n        }\n      }\n    }\n  }\n`);\n\nconst GlobalActionMetadataQuery = graphql(/* GraphQL */ `\n  query GlobalActionMetadata($apiIdentifier: String!, $namespace: [String!]) {\n    gadgetMeta {\n      globalAction(apiIdentifier: $apiIdentifier, namespace: $namespace) {\n        name\n        apiIdentifier\n        inputFields {\n          ...FieldMetadata\n          ...SubFields\n        }\n        triggers {\n          specID\n        }\n      }\n    }\n  }\n`);\n\nconst RolesMetadataQuery = graphql(/* GraphQL */ `\n  query RolesMetadata {\n    gadgetMeta {\n      roles {\n        name\n        key\n        selectable\n      }\n    }\n  }\n`);\n\ntype MapConfigurationKey<T, K extends string, NewType> = T extends any\n  ? {\n      [P in keyof T]: P extends K ? NewType : T[P];\n    }\n  : never;\n\ntype MapUnionConfigurationKey<U, K extends string, NewType> = U extends any ? MapConfigurationKey<U, K, NewType> : never;\n\n/**\n * The metadata blob retrieved for one field from the backend\n * Uses this weird typescript type to augment the raw GraphQL return type with the effect of the treeification which points to rich related model metadata\n */\nexport interface FieldMetadata {\n  __typename?: \"GadgetModelField\" | \"GadgetObjectField\";\n  name: string;\n  apiIdentifier: string;\n  fieldType: GadgetFieldType;\n  requiredArgumentForInput: boolean;\n  sortable?: boolean;\n  filterable?: boolean;\n  configuration: MapUnionConfigurationKey<FieldMetadataFragmentType[\"configuration\"], \"relatedModel\", ModelMetadata>;\n}\n\n/**\n * The metadata blob retrieved for one model from the backend\n */\nexport type ModelMetadata = Clarify<\n  Omit<Exclude<ResultOf<typeof ModelMetadataQuery>[\"gadgetMeta\"][\"modelAndRelatedModels\"][number], null | undefined>, \"fields\"> & {\n    fields: FieldMetadata[];\n  }\n>;\n\n/**\n * The metadata blob retrieved for one model action from the backend\n */\nexport type ActionMetadata = Clarify<\n  Omit<\n    Exclude<Exclude<ResultOf<typeof ModelActionMetadataQuery>[\"gadgetMeta\"][\"model\"], null | undefined>[\"action\"], null | undefined>,\n    \"inputFields\"\n  > & {\n    inputFields: FieldMetadata[];\n  }\n>;\n\n/**\n * The metadata blob retrieved for one model with one specific action from the backend\n */\nexport type ModelWithOneActionMetadata = Clarify<\n  Omit<Exclude<ResultOf<typeof ModelActionMetadataQuery>[\"gadgetMeta\"][\"model\"], null | undefined>, \"action\"> & { action: ActionMetadata }\n>;\n\nexport type GlobalActionMetadata = Clarify<\n  Omit<Exclude<ResultOf<typeof GlobalActionMetadataQuery>[\"gadgetMeta\"][\"globalAction\"], null | undefined>, \"inputFields\"> & {\n    inputFields: FieldMetadata[];\n  }\n>;\n\n/** The gadget metaschema returns models as a flat list of models to avoid infinite recursion. Re-build the circular references among all the related models client side here */\nconst treeifyModelMetadata = <T extends { key: string; fields: FieldMetadata[]; action?: ActionMetadata }>(models: T[]): T => {\n  const modelsByKey: Record<string, T> = {};\n  for (const model of models) {\n    modelsByKey[model.key] = model;\n  }\n\n  const setupRelatedModelReference = (fields: FieldMetadata[]) => {\n    for (const field of fields) {\n      if (\"relatedModel\" in field.configuration && field.configuration.relatedModel) {\n        (field.configuration as any).relatedModel = modelsByKey[field.configuration.relatedModel.key];\n      }\n\n      if (field.configuration.__typename == \"GadgetObjectFieldConfig\" && \"fields\" in field.configuration) {\n        setupRelatedModelReference(field.configuration.fields as FieldMetadata[]);\n      }\n    }\n  };\n\n  for (const model of models) {\n    setupRelatedModelReference(model.fields);\n\n    if (\"action\" in model && model.action) {\n      setupRelatedModelReference(model.action.inputFields);\n    }\n  }\n\n  return models[0];\n};\n\n/**\n * Retrieve a given Gadget model's metadata from the backend\n * @internal\n */\nexport const useModelMetadata = (\n  apiIdentifier: string,\n  namespace: string[]\n): { metadata: ModelMetadata | undefined; fetching: boolean; error: ErrorWrapper | undefined } => {\n  const [{ data, fetching, error }] = useGadgetQuery({\n    query: ModelMetadataQuery,\n    variables: {\n      apiIdentifier,\n      namespace,\n    },\n  });\n\n  return {\n    metadata: data\n      ? assert(\n          treeifyModelMetadata(data.gadgetMeta.modelAndRelatedModels as unknown as ModelMetadata[]),\n          \"no model metadata found in response from Gadget API\"\n        )\n      : data,\n    fetching,\n    error: error ? ErrorWrapper.forClientSideError(error) : undefined,\n  };\n};\n\nconst getGlobalActionApiIdentifier = (api: AnyClient, fn: GlobalActionFunction<any>) => {\n  let cursor: any = api;\n  if (fn.namespace) {\n    for (const segment of Array.isArray(fn.namespace) ? fn.namespace : [fn.namespace]) {\n      cursor = cursor[segment];\n    }\n  }\n  for (const [key, value] of Object.entries(cursor)) {\n    if (value === fn) {\n      return key;\n    }\n  }\n  throw new Error(\"global action function not found on model manager\");\n};\n\n/**\n * Retrieve a given Gadget model action's metadata from the backend\n * @internal\n */\nexport const useActionMetadata = (\n  actionFunction: ActionFunction<any, any, any, any, any> | GlobalActionFunction<any>\n): { metadata: ModelWithOneActionMetadata | GlobalActionMetadata | undefined; fetching: boolean; error: ErrorWrapper | undefined } => {\n  const api = useApi();\n\n  let query: DocumentNode;\n  let variables: Record<string, any>;\n\n  if (actionFunction.type === \"globalAction\") {\n    query = GlobalActionMetadataQuery;\n    variables = {\n      apiIdentifier: getGlobalActionApiIdentifier(api, actionFunction),\n      namespace: actionFunction.namespace,\n    };\n  } else if (actionFunction.type === \"action\") {\n    query = ModelActionMetadataQuery;\n    const modelManager = assert(\n      getModelManager(api, actionFunction.modelApiIdentifier, actionFunction.namespace),\n      \"no model manager found for action function\"\n    );\n    let actionName;\n    const proto = Object.getPrototypeOf(modelManager);\n    for (const [key, value] of Object.entries(proto)) {\n      if (value === actionFunction) {\n        actionName = key;\n        break;\n      }\n    }\n    if (!actionName) {\n      // Fallback to string parsing if the action name is not found\n      actionName = actionFunction.operationName.slice(0, -actionFunction.modelApiIdentifier.length);\n      if (!actionName || !(actionName in modelManager)) {\n        throw new Error(\"action function not found on model manager\");\n      }\n    }\n    variables = {\n      modelApiIdentifier: actionFunction.modelApiIdentifier,\n      modelNamespace: actionFunction.namespace,\n      action: actionName,\n    };\n  } else {\n    throw new Error(`Invalid action function type`);\n  }\n\n  const [{ data, fetching, error }] = useGadgetQuery({\n    query,\n    variables,\n  });\n\n  let metadata: ModelWithOneActionMetadata | GlobalActionMetadata | undefined = undefined;\n\n  if (data && !error) {\n    if (\"globalAction\" in data.gadgetMeta) {\n      metadata = assert(\n        (data as ResultOf<typeof GlobalActionMetadataQuery>).gadgetMeta.globalAction,\n        \"no global action metadata found from Gadget API\"\n      ) as GlobalActionMetadata;\n    } else {\n      const typedData = data as ResultOf<typeof ModelActionMetadataQuery>;\n      assert(typedData.gadgetMeta.model?.action, \"no model metadata found from Gadget API\");\n\n      // merge fields fetched from one spot with action fetched from the other spot\n      const mainModel = {\n        ...typedData.gadgetMeta.model,\n        ...typedData.gadgetMeta.modelAndRelatedModels[0],\n      };\n\n      const models: ModelMetadata[] = [mainModel, ...typedData.gadgetMeta.modelAndRelatedModels.slice(1)] as any;\n      metadata = treeifyModelMetadata(models) as unknown as ModelWithOneActionMetadata;\n    }\n  }\n\n  return {\n    metadata,\n    fetching,\n    error: error ? ErrorWrapper.forClientSideError(error) : undefined,\n  };\n};\n\n/**\n * @internal\n */\nexport const filterAutoFormFieldList = (\n  fields: FieldMetadata[] | undefined,\n  options?: { include?: string[]; exclude?: string[]; isUpsertAction?: boolean }\n): FieldMetadata[] => {\n  if (!fields) {\n    return [];\n  }\n\n  let subset = fields;\n\n  if (options?.include && options?.exclude) {\n    throw new Error(\"Cannot use both 'include' and 'exclude' options at the same time\");\n  }\n\n  if (options?.include) {\n    // When including fields, the order will match the order of the `include` array\n    subset = [];\n    const includes = new Set(options.include);\n\n    for (const includedFieldApiId of Array.from(includes)) {\n      const metadataField = fields.find((field) => field.apiIdentifier === includedFieldApiId);\n      if (metadataField) {\n        subset.push(metadataField);\n      }\n    }\n  }\n\n  if (options?.exclude) {\n    const excludes = new Set(options.exclude);\n    subset = subset.filter((field) => !excludes.has(field.apiIdentifier));\n  }\n\n  // Remove `hasMany` fields that emerge from `hasManyThrough` fields that are not actually model fields\n  subset = subset.filter((field) => !isJoinModelHasManyField(field));\n\n  // Filter out fields that are not supported by the form\n  const validFieldTypeSubset = subset.filter(options?.isUpsertAction ? isAcceptedUpsertFieldType : isAcceptedFieldType);\n\n  return options?.include\n    ? validFieldTypeSubset // Everything explicitly included is valid\n    : validFieldTypeSubset.filter(isNotRelatedToSpecialModelFilter); // Without explicit includes, filter out relationships to special models\n};\n\n/**\n * Filters out relationship fields that are related to special models\n */\nconst isNotRelatedToSpecialModelFilter = (field: FieldMetadata) => {\n  const relatedModelKey =\n    field.configuration &&\n    \"relatedModel\" in field.configuration &&\n    field.configuration.relatedModel &&\n    field.configuration.relatedModel.key;\n  return typeof relatedModelKey === \"string\" ? !specialModelKeys.has(relatedModelKey) : true;\n};\n\nconst specialModelKeys = new Set([\"DataModel-Shopify-Shop\"]);\n\nconst isAcceptedFieldType = (field: FieldMetadata) => acceptedAutoFormFieldTypes.has(field.fieldType);\nconst isAcceptedUpsertFieldType = (field: FieldMetadata) => field.fieldType === FieldType.Id || isAcceptedFieldType(field);\n\nconst isJoinModelHasManyField = (field: FieldMetadata) =>\n  field.fieldType === FieldType.HasMany &&\n  field.configuration.__typename === \"GadgetHasManyConfig\" &&\n  field.configuration.isJoinModelHasManyField;\n\nconst acceptedAutoFormFieldTypes = new Set([\n  FieldType.Boolean,\n  FieldType.Color,\n  FieldType.Computed, // Not rendered as an input\n  FieldType.DateTime,\n  FieldType.Email,\n  FieldType.EncryptedString,\n  FieldType.Enum,\n  FieldType.File,\n  FieldType.Json,\n  FieldType.Number,\n  FieldType.Password,\n  FieldType.RichText,\n  FieldType.RoleAssignments,\n  FieldType.String,\n  FieldType.Url,\n  FieldType.Vector, // Not rendered as an input\n  FieldType.RichText,\n\n  // Relationships\n  FieldType.BelongsTo,\n  FieldType.HasMany,\n  FieldType.HasOne,\n]);\n\nexport const filterAutoTableFieldList = (fields: FieldMetadata[]) => {\n  let subset = fields;\n\n  // Don't include relationships in the table by default\n  subset = subset.filter(\n    (field) =>\n      field.fieldType !== GadgetFieldType.HasOne &&\n      field.fieldType !== GadgetFieldType.HasMany &&\n      field.fieldType !== GadgetFieldType.BelongsTo\n  );\n\n  // Filter out fields that are not supported by the form\n  return subset.filter((field) => acceptedAutoTableFieldTypes.has(field.fieldType));\n};\n\nexport const acceptedAutoTableFieldTypes = new Set([\n  FieldType.Id,\n  FieldType.Boolean,\n  FieldType.Color,\n  FieldType.Computed,\n  FieldType.DateTime,\n  FieldType.Email,\n  FieldType.EncryptedString,\n  FieldType.Enum,\n  FieldType.File,\n  FieldType.Json,\n  FieldType.Number,\n  FieldType.RichText,\n  FieldType.RoleAssignments,\n  FieldType.String,\n  FieldType.Url,\n  FieldType.RichText,\n\n  // Relationships\n  FieldType.BelongsTo,\n  FieldType.HasMany,\n  FieldType.HasManyThrough,\n  FieldType.HasOne,\n]);\n\n/**\n * Retrieve the roles available in the Gadget app from the backend\n * @internal\n */\nexport const useRolesMetadata = () => {\n  const [{ data, fetching, error }] = useGadgetQuery({\n    query: RolesMetadataQuery,\n  });\n\n  return {\n    roles: data?.gadgetMeta.roles,\n    fetching,\n    error: error ? ErrorWrapper.forClientSideError(error) : undefined,\n  };\n};\n\nexport const isModelActionMetadata = (\n  metadata: ModelWithOneActionMetadata | GlobalActionMetadata\n): metadata is ModelWithOneActionMetadata => {\n  return \"action\" in metadata;\n};\n"]}